<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>OpenGL实现屏幕空间的环境光遮蔽（SSAO） | 梓见</title><meta name="author" content="梓见"><meta name="copyright" content="梓见"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="项目源码 背景知识SSAOBling-Phong反射模型将光照分成了三个部分：环境光（Ambient），漫反射（Diffuse）以及镜面反射（Specular），该模型假设环境光为一个常数。而在真实世界中，环境光不可能为一个常数，环境光遮蔽（AO）技术就是为了解决这一问题。传统的环境光遮蔽技术需要在世界空间中每一点发射大量光线来确定遮蔽量，如此庞大的计算量使得其运用在实时运算中非常困难。所以在20">
<meta property="og:type" content="article">
<meta property="og:title" content="OpenGL实现屏幕空间的环境光遮蔽（SSAO）">
<meta property="og:url" content="http://example.com/2022/11/07/ssao/index.html">
<meta property="og:site_name" content="梓见">
<meta property="og:description" content="项目源码 背景知识SSAOBling-Phong反射模型将光照分成了三个部分：环境光（Ambient），漫反射（Diffuse）以及镜面反射（Specular），该模型假设环境光为一个常数。而在真实世界中，环境光不可能为一个常数，环境光遮蔽（AO）技术就是为了解决这一问题。传统的环境光遮蔽技术需要在世界空间中每一点发射大量光线来确定遮蔽量，如此庞大的计算量使得其运用在实时运算中非常困难。所以在20">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7">
<meta property="article:published_time" content="2022-11-07T15:49:54.000Z">
<meta property="article:modified_time" content="2022-12-16T12:05:16.294Z">
<meta property="article:author" content="梓见">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2022/11/07/ssao/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: true,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'OpenGL实现屏幕空间的环境光遮蔽（SSAO）',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-12-16 20:05:16'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.1.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://cdn.jsdelivr.net/gh/uestctangzijian/picbed@main/kabi.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data is-center"><div class="data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">3</div></a></div><div class="data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a></div><div class="data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">梓见</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">OpenGL实现屏幕空间的环境光遮蔽（SSAO）</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-11-07T15:49:54.000Z" title="发表于 2022-11-07 23:49:54">2022-11-07</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-12-16T12:05:16.294Z" title="更新于 2022-12-16 20:05:16">2022-12-16</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="OpenGL实现屏幕空间的环境光遮蔽（SSAO）"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p><a target="_blank" rel="noopener" href="https://github.com/uestctangzijian/SSAO">项目源码</a></p>
<h1 id="背景知识"><a href="#背景知识" class="headerlink" title="背景知识"></a>背景知识</h1><h2 id="SSAO"><a href="#SSAO" class="headerlink" title="SSAO"></a>SSAO</h2><p>Bling-Phong反射模型将光照分成了三个部分：环境光（Ambient），漫反射（Diffuse）以及镜面反射（Specular），该模型假设环境光为一个常数。而在真实世界中，<strong>环境光</strong>不可能为一个常数，环境光遮蔽（AO）技术就是为了解决这一问题。<br>传统的环境光遮蔽技术需要在<strong>世界空间</strong>中每一点发射大量光线来确定遮蔽量，如此庞大的计算量使得其运用在实时运算中非常困难。所以在2007年，Crytek公司发明了屏幕空间的环境光遮蔽（SSAO）的技术，并用在了看家作孤岛危机上。这里的“屏幕空间”指的是指运用屏幕空间中的信息，我们知道在图形管线中，屏幕空间是指经过模型、视图、投影、视口变换得到的空间，此时不可见片段的信息已被丢弃，所以在<strong>屏幕空间</strong>中的计算量远小于世界空间的计算量。这使得该算法相对于传统的AO不但速度快，而且还能获得很好的效果。<br>那么AO技术能带来什么呢？上面也提到，AO技术对环境光的模拟更加精确，给我们最直观的感受是它让<strong>场景中物体的相对位置关系更加明显，给整个场景带来了更强的深度感</strong>。</p>
<p><img src="/images/ssaodiff.png"></p>
<p>上图是一个最直观的例子，对比两张图的墙角，面的接缝处，发现使用了SSAO后这些地方的颜色会更加深，阴影更加明显，整体效果更加真实。<br>关于SSAO的推导本文不作过多阐述，推荐闫玲琪大佬的<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1YK4y1T7yY">GAMES202课程</a>，这里直接贴出<a target="_blank" rel="noopener" href="https://sites.cs.ucsb.edu/~lingqi/teaching/resources/GAMES202_Lecture_08.pdf">PPT</a>中的一张图：</p>
<p><img src="/images/ssaoformula.png"></p>
<p>可以由BDRF公式推出如上结果，式中Li是光的颜色，ρ&#x2F;π中的ρ指的是物体的漫反射材质，二者都是一个常数，所以要计算的只有式子右边的积分，这个积分也就是<strong>环境光遮蔽因子（Occulsion Factor）</strong>。<br>具体的计算方式是：对于屏幕上的每一个片段&#x2F;像素，我们在周围一定半径的球形内采样，比较这些采样点的深度值和z-buffer中对于位置的深度值，如果采样点深度值更大，说明它们不可见，也就对遮蔽因子有贡献；在球形内这样的采样点越多，该片段的环境光就越少。</p>
<p><img src="/images/ssaokernel.png"></p>
<p>显然，更多的样本数意味着更高的渲染质量。如果样本数量太低，渲染精度会减少，会得到一种叫<strong>波纹（Banding）</strong>的效果；如果太高，则会影响性能。我们可以引入随机性到采样核心的采样中从而减少样本的数目。通过随机旋转采样核心，可以在有限样本数量中得到高质量的结果。这样做带来的副作用是，随机性引入了一个噪声图案，所以我们需要对结果进行模糊来修改这一问题。下图（来自<a target="_blank" rel="noopener" href="http://john-chapman-graphics.blogspot.com/">John Chapman</a>）展示了波纹效果还有随机性造成的效果：</p>
<p><img src="/images/ssaobanding.png"></p>
<p>可以看到，低样本数带来了很明显的波纹效果，引入随机性后这些波纹效果就完全消失了。<br>SSAO也有其缺点，因为采样核是一个球体，它会导致平整的墙面也会显得灰蒙蒙的，因为核心中一半的样本都在墙体内，所以在计算的时候会对遮蔽因子有贡献，而这一部分本不应该影响遮蔽因子。<br>下图展示是孤岛危机的SSAO，它体现了这种灰蒙蒙的感觉：</p>
<p><img src="/images/crisis_ssao.png"></p>
<p>显然，以法向量所在半球为采样核心更为合适，之前或是由于技术的限制，在采样核时没有法向量的信息。但是在现代图形学中，法向量很容易被获取，自然就不必再用球体。<br>通过<strong>法向半球体(Normal-oriented Hemisphere)<strong>周围采样，我们不会考虑到片段底部的几何体，它消除了环境光遮蔽灰蒙蒙的感觉，从而产生更真实的结果。这种改进的SSAO技术也叫做</strong>HABO</strong>，在下面的OpenGL实现中，我们采用的实际上是HABO技术。</p>
<h2 id="延迟渲染"><a href="#延迟渲染" class="headerlink" title="延迟渲染"></a>延迟渲染</h2><p>延时渲染（Deffered Rendering）是将着色的计算延后处理的一种渲染方法，它可以有效的减少场景有<strong>大量光源</strong>时的渲染时间。<br>回想一下传统的正向渲染（Forward Rendering）的过程：在把三角形网格离散化成片段之后，我们对每个片段执行深度测试，如果通过了深度测试，就对它进行着色。这个过程存在一个问题，我们不确定片段是以何种顺序被传往管线的，假如先对深度大的片段进行着色，再对深度小的片段着色，那么旧的片段就会被新的片段覆盖。一个最差的情况是，我们刚好从后往前渲染一个物体，那么很多先渲染的片段最终并不会展示，这部分的计算时间就被浪费掉了。<br>假设场景中有n个片段，m个光源，那么正向渲染的时间复杂度就是O(n *m)。<br>延时渲染的提出就是为了解决以上问题，他可以只渲染场景中的<strong>可见片段</strong>，从而将时间复杂度减小到O(vis n *m)。<br>延时渲染的思想是将原来的<strong>一次光栅拆成了两次光栅</strong>。在Pass1中，我们不去做着色的部分，更新深度buffer，并且将几何信息（如位置，法线，反射颜色等）存入到几何缓冲区（G-buffer）中；到了pass2，我们在利用一阶段存储的几何信息，对屏幕空间中的像素计算着色，从而避免了因计算会被深度测试丢弃片段着色而产生的不必要的开销。<br>这里给出正向渲染和延迟渲染的管线对比图，来自<a target="_blank" rel="noopener" href="https://blog.csdn.net/poem_qianmo/article/details/77142101">毛星云的博客</a>：</p>
<p><img src="/images/forwardvsdeffered.png"></p>
<p>延迟渲染有效的降低了正向渲染的时间复杂度，对后处理支持良好，在大量光源场景下优势明显，但是也有其缺点：</p>
<ul>
<li>由于延迟渲染是用空间换时间，所以显存的压力大；</li>
<li>对透明物体的渲染存在问题，需要结合正向渲染；</li>
<li>对多重采样抗锯齿（MSAA）支持不友好，可以用TAA解决。</li>
</ul>
<p>针对延迟渲染的这些问题，人们又提出了一些改进算法，如延迟光照（Deffered Lighting），分块延迟渲染（Tile-BaseDeffered Rendering）等，与本文关系不大，这里不过多赘述。</p>
<h1 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h1><p>上文我们先介绍了延迟渲染的知识，是因为SSAO的实现步骤完美适配延迟渲染的思想。<br>回想一下SSAO的核心步骤，我们需要对屏幕上的每个像素取一个采样核，在采样核中随机采样一些点判断其对遮蔽因子的影响。在这个计算过程中，我们免不了要用到每个像素的位置及其法向量。还记得我们在延迟渲染的Pass1做了什么吗？我们已经将位置，法向量等信息存到了G-buffer中，所以我们现在可以在SSAO中使用了！<br>SSAO的整个过程正是将延迟渲染的两个pass扩展成了四个pass，如下图：</p>
<p><img src="/images/ssaostep.png"></p>
<p>Pass1 几何处理阶段：将片段的位置，法向量，反射颜色存入到G-buffer中，供后续使用；<br>Pass2 SSAO阶段：计算采样核心、随机旋转向量，再加上Pass1存的位置，法向量，传入SSAO着色器中计算出遮蔽因子；<br>Pass3 模糊阶段：这一阶段我们需要对上一阶段算出的遮蔽因子进行模糊&#x2F;卷积，去除噪声；<br>Pass4 光照处理阶段：使用G-buffer，遮蔽因子计算场景的光照。<br>下面详细介绍了每个阶段的实现细节。</p>
<h2 id="几何处理阶段"><a href="#几何处理阶段" class="headerlink" title="几何处理阶段"></a>几何处理阶段</h2><p>在几何处理阶段中我们需要存储片段的位置，法向量，反射颜色信息到G-buffer中，在OpenGL中我们可以用三个纹理分别存储这三种向量。<br>几何阶段的片段着色器比较简单，输出这三种几何信息即可：</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// geometry.fs</span></span><br><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line"><span class="keyword">layout</span> (<span class="keyword">location</span> = <span class="number">0</span>) <span class="keyword">out</span> <span class="type">vec3</span> gPosition;</span><br><span class="line"><span class="keyword">layout</span> (<span class="keyword">location</span> = <span class="number">1</span>) <span class="keyword">out</span> <span class="type">vec3</span> gNormal;</span><br><span class="line"><span class="keyword">layout</span> (<span class="keyword">location</span> = <span class="number">2</span>) <span class="keyword">out</span> <span class="type">vec4</span> gAlbedo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">in</span> <span class="type">vec2</span> TexCoords;</span><br><span class="line"><span class="keyword">in</span> <span class="type">vec3</span> FragPos;</span><br><span class="line"><span class="keyword">in</span> <span class="type">vec3</span> Normal;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main()</span><br><span class="line">&#123;</span><br><span class="line">    gPosition = FragPos;</span><br><span class="line">    gNormal = <span class="built_in">normalize</span>(Normal);</span><br><span class="line">    gAlbedo.rgb = <span class="type">vec3</span>(<span class="number">0.95</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个片段着色器将物体的反射颜色设成一个常数，如果我们需要用到纹理，只需要改一下gAlbedo的值，让它的rgb等于漫反射颜色，a等于镜面反射即可。</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// geometry.fs</span></span><br><span class="line"><span class="keyword">uniform</span> <span class="type">sampler2D</span> texture_diffuse1;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">sampler2D</span> texture_specular1;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main()</span><br><span class="line">&#123;</span><br><span class="line">    gAlbedo.rgb = <span class="built_in">texture</span>(texture_diffuse1, TexCoords).rgb;</span><br><span class="line">    gAlbedo.a = <span class="built_in">texture</span>(texture_specular1, TexCoords).r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>之后我们需要将几何信息存储到纹理中，这里以gPosition举例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> gBuffer;</span><br><span class="line"><span class="built_in">glGenFramebuffers</span>(<span class="number">1</span>, &amp;gBuffer);</span><br><span class="line"><span class="built_in">glBindFramebuffer</span>(GL_FRAMEBUFFER, gBuffer);</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> gPosition;</span><br><span class="line"><span class="comment">// position color buffer</span></span><br><span class="line"><span class="built_in">glGenTextures</span>(<span class="number">1</span>, &amp;gPosition);</span><br><span class="line"><span class="built_in">glBindTexture</span>(GL_TEXTURE_2D, gPosition);</span><br><span class="line"><span class="built_in">glTexImage2D</span>(GL_TEXTURE_2D, <span class="number">0</span>, GL_RGBA16F, SCR_WIDTH, SCR_HEIGHT, <span class="number">0</span>, GL_RGBA, GL_FLOAT, <span class="literal">NULL</span>);</span><br><span class="line"><span class="built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);</span><br><span class="line"><span class="built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);</span><br><span class="line"><span class="built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);</span><br><span class="line"><span class="built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);</span><br><span class="line"><span class="built_in">glFramebufferTexture2D</span>(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D, gPosition, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<p>因为我们需要用到延迟渲染的优势，只对屏幕空间中的像素计算着色，所以还需要对G-buffer开启深度检测，使它只存储可见点的信息。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> rboDepth;</span><br><span class="line"><span class="built_in">glGenRenderbuffers</span>(<span class="number">1</span>, &amp;rboDepth);</span><br><span class="line"><span class="built_in">glBindRenderbuffer</span>(GL_RENDERBUFFER, rboDepth);</span><br><span class="line"><span class="built_in">glRenderbufferStorage</span>(GL_RENDERBUFFER, GL_DEPTH_COMPONENT, SCR_WIDTH, SCR_HEIGHT);</span><br><span class="line"><span class="built_in">glFramebufferRenderbuffer</span>(GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT, GL_RENDERBUFFER, rboDepth);</span><br></pre></td></tr></table></figure>
<h2 id="SSAO阶段"><a href="#SSAO阶段" class="headerlink" title="SSAO阶段"></a>SSAO阶段</h2><p>这部分涉及到切线空间，TBN矩阵， 施密特正交化的知识，可以看下<a target="_blank" rel="noopener" href="https://learnopengl.com/Advanced-Lighting/Normal-Mapping">learnOpengl法线贴图</a>章节。</p>
<h3 id="法线方向的采样半球"><a href="#法线方向的采样半球" class="headerlink" title="法线方向的采样半球"></a>法线方向的采样半球</h3><p>在SSAO阶段，我们首先需要生成采样核，并在采样核里随机选取一些点。如果我们对每个表面法线方向都生成样本核非常困难也不合理，所以我们可以在切线空间中生成一个统一的样本核，法向量指向正z方向，之后再将样本核转换到视图空间中。<br>假设生成单位半球，一个样本核有64个样本，代码应该像这样：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::uniform_real_distribution&lt;<span class="type">float</span>&gt; <span class="title">randomFloats</span><span class="params">(<span class="number">0.0</span>, <span class="number">1.0</span>)</span></span>; <span class="comment">// random floats between [0.0, 1.0]</span></span><br><span class="line">std::default_random_engine generator;</span><br><span class="line">std::vector&lt;glm::vec3&gt; ssaoKernel;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">unsigned</span> <span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">64</span>; ++i)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">glm::vec3 <span class="title">sample</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        randomFloats(generator) * <span class="number">2.0</span> - <span class="number">1.0</span>, </span></span></span><br><span class="line"><span class="params"><span class="function">        randomFloats(generator) * <span class="number">2.0</span> - <span class="number">1.0</span>, </span></span></span><br><span class="line"><span class="params"><span class="function">        randomFloats(generator)</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span>;</span><br><span class="line">    sample  = glm::<span class="built_in">normalize</span>(sample);</span><br><span class="line">    sample *= <span class="built_in">randomFloats</span>(generator);</span><br><span class="line">    ssaoKernel.<span class="built_in">push_back</span>(sample);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中x和y位于[-1,1]，z是[0,1]，所以是个半球体。<br>现在所有的样本是随机分布在样本内核中的，但根据常识，离实际片段更近的点应该有更大的权重，所以我们需要更多的样本点分布在原点周围。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> <span class="type">float</span> scale = (<span class="type">float</span>)i / <span class="number">64.0</span>; </span><br><span class="line">   scale   = <span class="built_in">lerp</span>(<span class="number">0.1f</span>, <span class="number">1.0f</span>, scale * scale);</span><br><span class="line">   sample *= scale;</span><br><span class="line">   ssaoKernel.<span class="built_in">push_back</span>(sample);  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">float</span> <span class="title">lerp</span><span class="params">(<span class="type">float</span> a, <span class="type">float</span> b, <span class="type">float</span> f)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + f * (b - a);</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<p>这里利用了二次函数性质：<br><img src="/images/x2graph.png"><br>相交与斜率为1的直线，大多数样本点的distance处于较低水平，也就离原点更近。</p>
<h3 id="随机内核旋转"><a href="#随机内核旋转" class="headerlink" title="随机内核旋转"></a>随机内核旋转</h3><p>通过在样本内核中引入随机性，我们可以用更少的样本得到良好的结果。如果为场景中的每个片段都创建一个随机旋转向量，会占用大量内存。一个更好的方案是创建固定数量的随机旋转向量，并将它平铺到整个屏幕上。<br>通常使用一个4x4大小的随机旋转向量数组：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;glm::vec3&gt; ssaoNoise;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">unsigned</span> <span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">16</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">glm::vec3 <span class="title">noise</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        randomFloats(generator) * <span class="number">2.0</span> - <span class="number">1.0</span>, </span></span></span><br><span class="line"><span class="params"><span class="function">        randomFloats(generator) * <span class="number">2.0</span> - <span class="number">1.0</span>, </span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="number">0.0f</span>)</span></span>; </span><br><span class="line">    ssaoNoise.<span class="built_in">push_back</span>(noise);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>样本内核在切线空间中沿正z方向，所以将noise的z设为0，即绕z轴旋转。<br>然后我们需要有一个4x4纹理存储随机旋转向量，将其Wrap设置为GL_REPEAT可以让这个4x4纹理平铺在整个屏幕上，偏于后续采样。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> noiseTexture;</span><br><span class="line"><span class="built_in">glGenTextures</span>(<span class="number">1</span>, &amp;noiseTexture);</span><br><span class="line"><span class="built_in">glBindTexture</span>(GL_TEXTURE_2D, noiseTexture);</span><br><span class="line"><span class="built_in">glTexImage2D</span>(GL_TEXTURE_2D, <span class="number">0</span>, GL_RGBA32F, <span class="number">4</span>, <span class="number">4</span>, <span class="number">0</span>, GL_RGB, GL_FLOAT, &amp;ssaoNoise[<span class="number">0</span>]);</span><br><span class="line"><span class="built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);</span><br><span class="line"><span class="built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);</span><br><span class="line"><span class="built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);</span><br><span class="line"><span class="built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);</span><br></pre></td></tr></table></figure>

<h3 id="SSAO着色器"><a href="#SSAO着色器" class="headerlink" title="SSAO着色器"></a>SSAO着色器</h3><p>有了上面的得到的数据后，我们就可以开始SSAO的计算了。首先需要将之前得到的位置，法向量，噪声纹理，样本点都传入片段着色器，然后还需要另一个framebuffer存储ssao计算得到的结果。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> ssaoFBO, ssaoColorBuffer;</span><br><span class="line"><span class="built_in">glGenFramebuffers</span>(<span class="number">1</span>, &amp;ssaoFBO);</span><br><span class="line"><span class="built_in">glBindFramebuffer</span>(GL_FRAMEBUFFER, ssaoFBO);</span><br><span class="line"><span class="comment">// SSAO color buffer</span></span><br><span class="line"><span class="built_in">glGenTextures</span>(<span class="number">1</span>, &amp;ssaoColorBuffer);</span><br><span class="line"><span class="built_in">glBindTexture</span>(GL_TEXTURE_2D, ssaoColorBuffer);</span><br><span class="line"><span class="built_in">glTexImage2D</span>(GL_TEXTURE_2D, <span class="number">0</span>, GL_RED, SCR_WIDTH, SCR_HEIGHT, <span class="number">0</span>, GL_RED, GL_FLOAT, <span class="literal">NULL</span>); <span class="comment">// occlusion是单个值，用红色分量即可</span></span><br><span class="line"><span class="built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);</span><br><span class="line"><span class="built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);</span><br><span class="line"><span class="built_in">glFramebufferTexture2D</span>(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D, ssaoColorBuffer, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">----------------------------------------------------------------------------------</span><br><span class="line"><span class="built_in">glBindFramebuffer</span>(GL_FRAMEBUFFER, ssaoFBO);</span><br><span class="line"><span class="built_in">glClear</span>(GL_COLOR_BUFFER_BIT);</span><br><span class="line">shaderSSAO.<span class="built_in">use</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">unsigned</span> <span class="type">int</span> i = <span class="number">0</span>; i &lt; ssaoKernel.<span class="built_in">size</span>(); i++)</span><br><span class="line">    shaderSSAO.<span class="built_in">setVec3</span>(<span class="string">&quot;samples[&quot;</span> + std::<span class="built_in">to_string</span>(i) + <span class="string">&quot;]&quot;</span>, ssaoKernel[i]);</span><br><span class="line">shaderSSAO.<span class="built_in">setMat4</span>(<span class="string">&quot;projection&quot;</span>, projection);</span><br><span class="line"><span class="built_in">glActiveTexture</span>(GL_TEXTURE0);</span><br><span class="line"><span class="built_in">glBindTexture</span>(GL_TEXTURE_2D, gPosition);</span><br><span class="line"><span class="built_in">glActiveTexture</span>(GL_TEXTURE1);</span><br><span class="line"><span class="built_in">glBindTexture</span>(GL_TEXTURE_2D, gNormal);</span><br><span class="line"><span class="built_in">glActiveTexture</span>(GL_TEXTURE2);</span><br><span class="line"><span class="built_in">glBindTexture</span>(GL_TEXTURE_2D, noiseTexture);</span><br><span class="line"><span class="built_in">renderQuad</span>(); </span><br><span class="line"><span class="built_in">glBindFramebuffer</span>(GL_FRAMEBUFFER, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<p>ssaoFBO是另一个framebuffer，用来存储ssao着色器计算的得到纹理ssaoColorBuffer。由于遮蔽因子是一个float型的值，所以用纹理的红色分量存储即可，因此将纹理图片设置为GL_RED。<br>在渲染阶段，我们传入gPostion，gNormal，noiseTexture及samples，并结果到ssaoFBO。<br>在ssao着色器中，我们G缓冲区纹理，噪声纹理和样本核作为输入：</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line"><span class="keyword">out</span> <span class="type">float</span> FragColor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">in</span> <span class="type">vec2</span> TexCoords;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uniform</span> <span class="type">sampler2D</span> gPosition;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">sampler2D</span> gNormal;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">sampler2D</span> texNoise;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uniform</span> <span class="type">vec3</span> samples[<span class="number">64</span>];</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">mat4</span> projection;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">vec2</span> noiseScale = <span class="type">vec2</span>(SCR_WIDTH/noiseSize, SCR_HEIGHT/noiseSize); </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>并且计算一个noiseScale变量，用于从平铺的噪声纹理里取随机旋转向量。纹理坐标TexCoords是一个0.0到1.0之间的值，所以我们将TexCoords成上noiseScale，再从texNoise中取值。</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">vec3</span> fragPos = <span class="built_in">texture</span>(gPosition, TexCoords).xyz; <span class="comment">// 计算点在视图空间的位置</span></span><br><span class="line"><span class="type">vec3</span> normal = <span class="built_in">normalize</span>(<span class="built_in">texture</span>(gNormal, TexCoords).rgb); <span class="comment">// 计算点在视图空间的法向量</span></span><br><span class="line"><span class="type">vec3</span> randomVec = <span class="built_in">normalize</span>(<span class="built_in">texture</span>(texNoise, TexCoords * noiseScale).xyz); <span class="comment">// 随机旋转向量 在切向空间</span></span><br></pre></td></tr></table></figure>
<p>接下来创建TBN矩阵，用于样本点从切向空间变换到视图空间。因为randomVec是随机生成的，我们用它构造的tangent也是随机的，我们给切向空间引入的随机性最后通过与样本点相乘带到样本中。</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 详见：https://learnopengl.com/Advanced-Lighting/Normal-Mapping</span></span><br><span class="line"><span class="comment">// Gram-Schmidt正交化</span></span><br><span class="line"><span class="type">vec3</span> tangent = <span class="built_in">normalize</span>(randomVec - normal * <span class="built_in">dot</span>(randomVec, normal));</span><br><span class="line"><span class="type">vec3</span> bitangent = <span class="built_in">cross</span>(normal, tangent);</span><br><span class="line"><span class="type">mat3</span> TBN = <span class="type">mat3</span>(tangent, bitangent, normal);</span><br></pre></td></tr></table></figure>
<p>这里使用施密特正交化构造TBN矩阵，详细知识参考法线贴图一节。<br>接下来遍历每一个核样本点，将样本从切向空间转换到视图空间，再将样本点的相对位置调整到以片段位置为基准的绝对位置。</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> occlusion = <span class="number">0.0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; kernelSize; ++i)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">vec3</span> samplePos = TBN * samples[i]; <span class="comment">// 样本点从切线空间变到视图空间，此时还是相对位置</span></span><br><span class="line">    samplePos = fragPos + samplePos * radius; <span class="comment">// 样本点 在视图空间 的绝对位置</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的kernelSize和radius是可以用来调整效果的变量，radius变量可以调整核半球的大小，我们在第结果分析中还会继续讨论。这里先把默认值设为64和0.5。<br>接下来我们要将样本点投影到屏幕空间，这样就能对样本点位置的可见深度进行采样。</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">vec4</span> <span class="keyword">offset</span> = <span class="type">vec4</span>(samplePos, <span class="number">1.0</span>);</span><br><span class="line"><span class="keyword">offset</span> = projection * <span class="keyword">offset</span>; <span class="comment">// 样本点 从视图空间投影到剪裁空间[-1, 1]</span></span><br><span class="line"><span class="keyword">offset</span>.xyz /= <span class="keyword">offset</span>.w; <span class="comment">// 透视除法</span></span><br><span class="line"><span class="keyword">offset</span>.xyz = <span class="keyword">offset</span>.xyz * <span class="number">0.5</span> + <span class="number">0.5</span>; <span class="comment">// 样本点 转换成NDC</span></span><br></pre></td></tr></table></figure>
<p>样本投影到剪辑空间后，执行透视除法，然后再将xyz转换为标准化设备坐标（NDC），这样xy都位于[0.0, 1.0]范围，与uv坐标的范围一致，我们就可以对位置纹理进行采样了。</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> sampleDepth = <span class="built_in">texture</span>(gPosition, <span class="keyword">offset</span>.xy).z; <span class="comment">// 获取样本点的xy在z-buffer中对应的深度值</span></span><br></pre></td></tr></table></figure>
<p>这里的sampleDepth就是从观察者视角（第一个未遮挡的可见片段）看到的采样位置xy的深度值，然后我们检查样本当前的深度值是否大于这个sampleDepth，如果是，则说明该样本点不可见，也就对遮蔽因子有贡献。</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">occlusion += (sampleDepth &gt;= samplePos.z + bias ? <span class="number">1.0</span> : <span class="number">0.0</span>)；</span><br></pre></td></tr></table></figure>
<p>这里添加一个变量bias，同样也是一个可调整的值，它可以在视觉上调整SSAO效果。<br>通过上面的方法计算的occlusion会导致图像上出现一些本不该出现的阴影。试想一种情况，当片段周围的样本点的深度与片段的深度相差很大（说明它们相距很远），但是因为这两个点是在屏幕空间中，被投影到一起了。这样的样本点如果对遮蔽因子有贡献，会造成两个原本不接触的物体相交处产生阴影。如下图佛像的边缘处：</p>
<p><img src="/images/rangecheck.png"></p>
<p>在闫玲琪的SSAO课程中也有这样的例子，如下图红圈里的阴影：</p>
<p><img src="/images/ssaofalse.png"></p>
<p>解决方法是引入范围检测，它考虑了片段深度与样本点深度差值的影响，当两者深度差别太大时，此样本点不应对遮蔽因子有贡献。</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 检查在视图空间中 样本点的深度是否在 计算点的采样半径内，如果是才对遮蔽因子有贡献</span></span><br><span class="line"><span class="type">float</span> rangeCheck = rangeCheckEnable ? <span class="built_in">smoothstep</span>(<span class="number">0.0</span>, <span class="number">1.0</span>, radius / <span class="built_in">abs</span>(fragPos.z - sampleDepth)) : <span class="number">1.0</span>f;</span><br><span class="line"><span class="comment">// 判断样本点的深度是否大于该点在视图空间的深度，bias 非必须，可以在视觉上调整SSAO的效果</span></span><br><span class="line">occlusion += (sampleDepth &gt;= samplePos.z + bias ? <span class="number">1.0</span> : <span class="number">0.0</span>) * rangeCheck;  </span><br></pre></td></tr></table></figure>
<p>最后一步，将内核大小对遮蔽因子的贡献进行归一化，并用1减去这个值，这样在计算光照的时候就可以直接用该结果乘上环境光。</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#125;</span><br><span class="line">   occlusion = <span class="number">1.0</span> - (occlusion / kernelSize);</span><br><span class="line">   FragColor = <span class="built_in">pow</span>(occlusion, power);</span><br></pre></td></tr></table></figure>
<p>这里又引入了一个变量power，作为可调节的值，它直接影响遮蔽因子的大小从而影响结果。<br>在完成了以上步骤后，如果直接用这个遮蔽因子计算光照，会得到一张有噪声的结果，所以还需要进行模糊操作。</p>
<h2 id="模糊阶段"><a href="#模糊阶段" class="headerlink" title="模糊阶段"></a>模糊阶段</h2><p>在第三阶段，我们要对ssao纹理进行模糊，所以需要另一个<a target="_blank" rel="noopener" href="https://learnopengl.com/Advanced-OpenGL/Framebuffers">帧缓冲区</a>，用于存储模糊后的结果。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> ssaoBlurFBO, ssaoColorBufferBlur;</span><br><span class="line"><span class="built_in">glGenFramebuffers</span>(<span class="number">1</span>, &amp;ssaoBlurFBO);</span><br><span class="line"><span class="built_in">glBindFramebuffer</span>(GL_FRAMEBUFFER, ssaoBlurFBO);</span><br><span class="line"><span class="built_in">glGenTextures</span>(<span class="number">1</span>, &amp;ssaoColorBufferBlur);</span><br><span class="line"><span class="built_in">glBindTexture</span>(GL_TEXTURE_2D, ssaoColorBufferBlur);</span><br><span class="line"><span class="built_in">glTexImage2D</span>(GL_TEXTURE_2D, <span class="number">0</span>, GL_RED, SCR_WIDTH, SCR_HEIGHT, <span class="number">0</span>, GL_RED, GL_FLOAT, <span class="literal">NULL</span>);</span><br><span class="line"><span class="built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);</span><br><span class="line"><span class="built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);</span><br><span class="line"><span class="built_in">glFramebufferTexture2D</span>(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D, ssaoColorBufferBlur, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<p>渲染时，将ssao的结果ssaoColorBuffer作为输入传入模糊着色器中。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">glBindFramebuffer</span>(GL_FRAMEBUFFER, ssaoBlurFBO);</span><br><span class="line"><span class="built_in">glClear</span>(GL_COLOR_BUFFER_BIT);</span><br><span class="line">shaderSSAOBlur.<span class="built_in">use</span>();</span><br><span class="line"><span class="built_in">glActiveTexture</span>(GL_TEXTURE0);</span><br><span class="line"><span class="built_in">glBindTexture</span>(GL_TEXTURE_2D, ssaoColorBuffer);</span><br><span class="line"><span class="built_in">renderQuad</span>();</span><br><span class="line"><span class="built_in">glBindFramebuffer</span>(GL_FRAMEBUFFER, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<p>在着色器中，对于每一个片段，取周围区域的遮蔽因子，求和再取平均，作为该片段最后的遮蔽因子。</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line"><span class="keyword">out</span> <span class="type">float</span> FragColor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">in</span> <span class="type">vec2</span> TexCoords;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uniform</span> <span class="type">sampler2D</span> ssaoInput;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">int</span> noiseSize;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">vec2</span> texelSize = <span class="number">1.0</span> / <span class="type">vec2</span>(<span class="built_in">textureSize</span>(ssaoInput, <span class="number">0</span>));</span><br><span class="line">    <span class="type">float</span> result = <span class="number">0.0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> x = - noiseSize/<span class="number">2</span>; x &lt; noiseSize/<span class="number">2</span>; x++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> y = -noiseSize/<span class="number">2</span>; y &lt; noiseSize/<span class="number">2</span>; y++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">vec2</span> <span class="keyword">offset</span> = <span class="type">vec2</span>(<span class="type">float</span>(x), <span class="type">float</span>(y)) * texelSize;</span><br><span class="line">            result += <span class="built_in">texture</span>(ssaoInput, TexCoords + <span class="keyword">offset</span>).r;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    FragColor = result / (noiseSize * noiseSize);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>采样的范围与噪声纹理的大小相同，在本例中是4x4大小。这里还使用了textureSize获取一个像素的大小，如此可以准确的对周围样本采样。正确做完模糊后，会发现噪声消失了。</p>
<h2 id="光照计算阶段"><a href="#光照计算阶段" class="headerlink" title="光照计算阶段"></a>光照计算阶段</h2><p>在最后一个阶段，我们应用之前模糊后的遮蔽因子，来计算最后的光照。如果使用的是Blinn-Phong模型，我们只需要将遮蔽因子乘上环境光分量即可。片段着色器如下：</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line"><span class="keyword">out</span> <span class="type">vec4</span> FragColor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">in</span> <span class="type">vec2</span> TexCoords;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uniform</span> <span class="type">sampler2D</span> gPosition;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">sampler2D</span> gNormal;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">sampler2D</span> gAlbedo;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">sampler2D</span> ssao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uniform</span> <span class="type">bool</span> ssaoEnable;</span><br><span class="line"></span><br><span class="line">struct Light &#123;</span><br><span class="line">    <span class="type">vec3</span> Position;</span><br><span class="line">    <span class="type">vec3</span> Color;</span><br><span class="line">    </span><br><span class="line">    <span class="type">float</span> Linear;</span><br><span class="line">    <span class="type">float</span> Quadratic;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">uniform</span> Light light;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main()</span><br><span class="line">&#123;             </span><br><span class="line">    <span class="comment">// retrieve data from gbuffer</span></span><br><span class="line">    <span class="type">vec3</span> FragPos = <span class="built_in">texture</span>(gPosition, TexCoords).rgb;</span><br><span class="line">    <span class="type">vec3</span> Normal = <span class="built_in">texture</span>(gNormal, TexCoords).rgb;</span><br><span class="line">    <span class="type">vec3</span> Diffuse = <span class="built_in">texture</span>(gAlbedo, TexCoords).rgb;</span><br><span class="line">    <span class="type">float</span> Specular = <span class="built_in">texture</span>(gAlbedo, TexCoords).a;</span><br><span class="line"></span><br><span class="line">    <span class="type">float</span> AmbientOcclusion = ssaoEnable ? <span class="built_in">texture</span>(ssao, TexCoords).r : <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// then calculate lighting as usual</span></span><br><span class="line">    <span class="type">vec3</span> ambient = <span class="type">vec3</span>(<span class="number">0.3</span> * Diffuse * AmbientOcclusion);</span><br><span class="line">    <span class="type">vec3</span> lighting  = ambient; </span><br><span class="line">    <span class="type">vec3</span> viewDir  = <span class="built_in">normalize</span>(-FragPos); <span class="comment">// viewpos is (0.0.0)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// diffuse</span></span><br><span class="line">    <span class="type">vec3</span> lightDir = <span class="built_in">normalize</span>(light.Position - FragPos);</span><br><span class="line">    <span class="type">vec3</span> diffuse = <span class="built_in">max</span>(<span class="built_in">dot</span>(Normal, lightDir), <span class="number">0.0</span>) * Diffuse * light.Color;</span><br><span class="line">    <span class="comment">// specular</span></span><br><span class="line">    <span class="type">vec3</span> halfwayDir = <span class="built_in">normalize</span>(lightDir + viewDir);  </span><br><span class="line">    <span class="type">float</span> spec = <span class="built_in">pow</span>(<span class="built_in">max</span>(<span class="built_in">dot</span>(Normal, halfwayDir), <span class="number">0.0</span>), <span class="number">8.0</span>);</span><br><span class="line">    <span class="type">vec3</span> specular = light.Color * spec * Specular;</span><br><span class="line">    <span class="comment">// attenuation</span></span><br><span class="line">    <span class="type">float</span> <span class="built_in">distance</span> = <span class="built_in">length</span>(light.Position - FragPos);</span><br><span class="line">    <span class="type">float</span> attenuation = <span class="number">1.0</span> / (<span class="number">1.0</span> + light.Linear * <span class="built_in">distance</span> + light.Quadratic * <span class="built_in">distance</span> * <span class="built_in">distance</span>);</span><br><span class="line">    diffuse *= attenuation;</span><br><span class="line">    specular *= attenuation;</span><br><span class="line">    lighting += diffuse + specular;</span><br><span class="line"></span><br><span class="line">    FragColor = <span class="type">vec4</span>(lighting, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="结果分析"><a href="#结果分析" class="headerlink" title="结果分析"></a>结果分析</h1><p>在这一章节中，我们将之前提到变量进行参数化，验证它们对最后效果的影响。</p>
<h2 id="样本数量KernelSize"><a href="#样本数量KernelSize" class="headerlink" title="样本数量KernelSize"></a>样本数量KernelSize</h2><p>更多的样本数量会带来更好的效果表现，但在我的测试中却发现，当调高样本数量时，遮蔽效果变淡了。</p>
<p><img src="/images/kernelsize.gif"></p>
<p>咱不清楚是何原因，欢迎大佬指出。</p>
<h2 id="样本核的半径radius"><a href="#样本核的半径radius" class="headerlink" title="样本核的半径radius"></a>样本核的半径radius</h2><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">samplePos = fragPos + samplePos * radius;</span><br></pre></td></tr></table></figure>
<p>radius的初始值是0.5，减少半径我们发现，遮蔽的效果越来越不明显，当减小到0时，遮蔽效果完全消失。这一表现与理论相符合，我们知道更小的核意味着更难捕捉到附近的物体，遮挡因子更小。<br>增大半径到1时，遮蔽效果有细微提升，并不明显。由此也可见采样半径并不需要设定的太高，对于该场景而言，0.3~0.5已经可以取得不错的效果。</p>
<p><img src="/images/radius.gif"></p>
<h2 id="深度bias"><a href="#深度bias" class="headerlink" title="深度bias"></a>深度bias</h2><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(sampleDepth &gt;= samplePos.z + bias ? <span class="number">1.0</span> : <span class="number">0.0</span>)</span><br></pre></td></tr></table></figure>
<p>bias这个变量本意上是为了允许样本的实际深度和可见深度有一定误差的，而gpu计算时并不会产生那么大的误差，这个值不应设的过大。我们将初始值定为0.025，根据计算方法可以推测，当该值越大时，样本点越难对遮蔽因子产生贡献，造成遮蔽效果越来越不明显。</p>
<p><img src="/images/bias.gif"></p>
<h2 id="遮蔽因子的幂指数power"><a href="#遮蔽因子的幂指数power" class="headerlink" title="遮蔽因子的幂指数power"></a>遮蔽因子的幂指数power</h2><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">occlusion = <span class="number">1.0</span> - (occlusion / kernelSize);</span><br><span class="line">FragColor = <span class="built_in">pow</span>(occlusion, power);</span><br></pre></td></tr></table></figure>
<p>这个变量的含义比较直接，我们直接对occlusion做幂运算，因为occlusion是一个0-1的值，所以结果会越来越小，也就是环境光越来越暗，遮蔽效果更明显。</p>
<p><img src="/images/power.gif"></p>
<h2 id="模糊"><a href="#模糊" class="headerlink" title="模糊"></a>模糊</h2><p>如果我们在计算光照之前不对遮蔽因子做模糊，图像中会有很多的噪声，如下图：</p>
<p><img src="/images/blur.gif"></p>
<p>可以看到，当不做模糊时，整张图有明显的网格状的噪声。</p>
<h2 id="范围检测Range-Check"><a href="#范围检测Range-Check" class="headerlink" title="范围检测Range Check"></a>范围检测Range Check</h2><p>上文也提到，如果没有范围检测，场景中会出现一些本不应该出现的遮蔽。<br>例如图中红色方框部分，背包的这部分离地面有一些距离，也就是说它们有一定的深度差，这些地方不应该对地面有如此强的遮蔽效果。</p>
<p><img src="/images/withrangecheck.png"></p>
<p>而有了范围检测后，这部分的遮蔽效果自然了很多。</p>
<p><img src="/images/withoutrangecheck.png"></p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>闫玲琪-GAMES101 <a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1X7411F744">https://www.bilibili.com/video/BV1X7411F744</a><br>闫玲琪-GAMES202 <a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1YK4y1T7yY">https://www.bilibili.com/video/BV1YK4y1T7yY</a><br>闫玲琪-GAMES202-lecture8 <a target="_blank" rel="noopener" href="https://sites.cs.ucsb.edu/~lingqi/teaching/resources/GAMES202_Lecture_08.pdf">https://sites.cs.ucsb.edu/~lingqi/teaching/resources/GAMES202_Lecture_08.pdf</a><br>闫玲琪-GAMES202-lecture14 <a target="_blank" rel="noopener" href="https://sites.cs.ucsb.edu/~lingqi/teaching/resources/GAMES202_Lecture_14.pdf">https://sites.cs.ucsb.edu/~lingqi/teaching/resources/GAMES202_Lecture_14.pdf</a><br>learnopengl-帧缓冲 <a target="_blank" rel="noopener" href="https://learnopengl.com/Advanced-OpenGL/Framebuffers">https://learnopengl.com/Advanced-OpenGL/Framebuffers</a><br>learnopengl-法线贴图 <a target="_blank" rel="noopener" href="https://learnopengl.com/Advanced-Lighting/Normal-Mapping">https://learnopengl.com/Advanced-Lighting/Normal-Mapping</a><br>learnopengl-延迟渲染 <a target="_blank" rel="noopener" href="https://learnopengl.com/Advanced-Lighting/Deferred-Shading">https://learnopengl.com/Advanced-Lighting/Deferred-Shading</a><br>learnopengl-SSAO <a target="_blank" rel="noopener" href="https://learnopengl.com/Advanced-Lighting/SSAO">https://learnopengl.com/Advanced-Lighting/SSAO</a><br>lygyue-延迟渲染 <a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/102134614">https://zhuanlan.zhihu.com/p/102134614</a><br>毛星宇-延迟渲染 <a target="_blank" rel="noopener" href="https://blog.csdn.net/poem_qianmo/article/details/77142101">https://blog.csdn.net/poem_qianmo/article/details/77142101</a><br>John-chapman-ssao <a target="_blank" rel="noopener" href="http://john-chapman-graphics.blogspot.com/">http://john-chapman-graphics.blogspot.com/</a></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">梓见</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2022/11/07/ssao/">http://example.com/2022/11/07/ssao/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">梓见</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/12/16/screenshake/"><img class="prev-cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">屏幕抖动的艺术-2D射击小游戏开发记录</div></div></a></div><div class="next-post pull-right"><a href="/2022/09/27/zombieCrisis/"><img class="next-cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">《僵尸危机：Unity重置版》开发全纪录</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://cdn.jsdelivr.net/gh/uestctangzijian/picbed@main/kabi.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">梓见</div><div class="author-info__description">记录生活学习的点点滴滴</div></div><div class="card-info-data is-center"><div class="card-info-data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">3</div></a></div><div class="card-info-data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a></div><div class="card-info-data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/uestctangzijian" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:420872708@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%83%8C%E6%99%AF%E7%9F%A5%E8%AF%86"><span class="toc-number">1.</span> <span class="toc-text">背景知识</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#SSAO"><span class="toc-number">1.1.</span> <span class="toc-text">SSAO</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BB%B6%E8%BF%9F%E6%B8%B2%E6%9F%93"><span class="toc-number">1.2.</span> <span class="toc-text">延迟渲染</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E6%AD%A5%E9%AA%A4"><span class="toc-number">2.</span> <span class="toc-text">实现步骤</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%A0%E4%BD%95%E5%A4%84%E7%90%86%E9%98%B6%E6%AE%B5"><span class="toc-number">2.1.</span> <span class="toc-text">几何处理阶段</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SSAO%E9%98%B6%E6%AE%B5"><span class="toc-number">2.2.</span> <span class="toc-text">SSAO阶段</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%95%E7%BA%BF%E6%96%B9%E5%90%91%E7%9A%84%E9%87%87%E6%A0%B7%E5%8D%8A%E7%90%83"><span class="toc-number">2.2.1.</span> <span class="toc-text">法线方向的采样半球</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9A%8F%E6%9C%BA%E5%86%85%E6%A0%B8%E6%97%8B%E8%BD%AC"><span class="toc-number">2.2.2.</span> <span class="toc-text">随机内核旋转</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SSAO%E7%9D%80%E8%89%B2%E5%99%A8"><span class="toc-number">2.2.3.</span> <span class="toc-text">SSAO着色器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A8%A1%E7%B3%8A%E9%98%B6%E6%AE%B5"><span class="toc-number">2.3.</span> <span class="toc-text">模糊阶段</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%89%E7%85%A7%E8%AE%A1%E7%AE%97%E9%98%B6%E6%AE%B5"><span class="toc-number">2.4.</span> <span class="toc-text">光照计算阶段</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BB%93%E6%9E%9C%E5%88%86%E6%9E%90"><span class="toc-number">3.</span> <span class="toc-text">结果分析</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%B7%E6%9C%AC%E6%95%B0%E9%87%8FKernelSize"><span class="toc-number">3.1.</span> <span class="toc-text">样本数量KernelSize</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%B7%E6%9C%AC%E6%A0%B8%E7%9A%84%E5%8D%8A%E5%BE%84radius"><span class="toc-number">3.2.</span> <span class="toc-text">样本核的半径radius</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B7%B1%E5%BA%A6bias"><span class="toc-number">3.3.</span> <span class="toc-text">深度bias</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%81%AE%E8%94%BD%E5%9B%A0%E5%AD%90%E7%9A%84%E5%B9%82%E6%8C%87%E6%95%B0power"><span class="toc-number">3.4.</span> <span class="toc-text">遮蔽因子的幂指数power</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A8%A1%E7%B3%8A"><span class="toc-number">3.5.</span> <span class="toc-text">模糊</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%8C%83%E5%9B%B4%E6%A3%80%E6%B5%8BRange-Check"><span class="toc-number">3.6.</span> <span class="toc-text">范围检测Range Check</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99"><span class="toc-number">4.</span> <span class="toc-text">参考资料</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2022/12/16/screenshake/" title="屏幕抖动的艺术-2D射击小游戏开发记录"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="屏幕抖动的艺术-2D射击小游戏开发记录"/></a><div class="content"><a class="title" href="/2022/12/16/screenshake/" title="屏幕抖动的艺术-2D射击小游戏开发记录">屏幕抖动的艺术-2D射击小游戏开发记录</a><time datetime="2022-12-16T12:30:32.000Z" title="发表于 2022-12-16 20:30:32">2022-12-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/11/07/ssao/" title="OpenGL实现屏幕空间的环境光遮蔽（SSAO）"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="OpenGL实现屏幕空间的环境光遮蔽（SSAO）"/></a><div class="content"><a class="title" href="/2022/11/07/ssao/" title="OpenGL实现屏幕空间的环境光遮蔽（SSAO）">OpenGL实现屏幕空间的环境光遮蔽（SSAO）</a><time datetime="2022-11-07T15:49:54.000Z" title="发表于 2022-11-07 23:49:54">2022-11-07</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/09/27/zombieCrisis/" title="《僵尸危机：Unity重置版》开发全纪录"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="《僵尸危机：Unity重置版》开发全纪录"/></a><div class="content"><a class="title" href="/2022/09/27/zombieCrisis/" title="《僵尸危机：Unity重置版》开发全纪录">《僵尸危机：Unity重置版》开发全纪录</a><time datetime="2022-09-26T19:06:21.000Z" title="发表于 2022-09-27 03:06:21">2022-09-27</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By 梓见</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>