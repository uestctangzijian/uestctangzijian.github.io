<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>《僵尸危机：Unity重置版》开发全纪录 | 梓见</title><meta name="author" content="梓见"><meta name="copyright" content="梓见"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="游玩地址项目源码 地图设计本项目实现了笔者最喜爱的一张地图MAXEY。这张地图由一些长方形的墙体和锥形的墙角组成，Unity已经提供了立方体cube，可以用来做墙面，而墙角顶部的四棱锥需要通过3D建模软件（笔者使用的是blender）生成后导入到unity中。这里也用代码渲染四棱锥，但是如果几何体越来越复杂，使用建模软件无疑是更加合理的一种方式。地图的效果如下。  玩家设计玩家的行为主要有以下三个">
<meta property="og:type" content="article">
<meta property="og:title" content="《僵尸危机：Unity重置版》开发全纪录">
<meta property="og:url" content="http://example.com/2022/09/27/zombieCrisis/index.html">
<meta property="og:site_name" content="梓见">
<meta property="og:description" content="游玩地址项目源码 地图设计本项目实现了笔者最喜爱的一张地图MAXEY。这张地图由一些长方形的墙体和锥形的墙角组成，Unity已经提供了立方体cube，可以用来做墙面，而墙角顶部的四棱锥需要通过3D建模软件（笔者使用的是blender）生成后导入到unity中。这里也用代码渲染四棱锥，但是如果几何体越来越复杂，使用建模软件无疑是更加合理的一种方式。地图的效果如下。  玩家设计玩家的行为主要有以下三个">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7">
<meta property="article:published_time" content="2022-09-26T19:06:21.000Z">
<meta property="article:modified_time" content="2022-09-27T12:05:27.334Z">
<meta property="article:author" content="梓见">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2022/09/27/zombieCrisis/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: true,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '《僵尸危机：Unity重置版》开发全纪录',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-09-27 20:05:27'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.1.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://cdn.jsdelivr.net/gh/uestctangzijian/picbed@main/kabi.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data is-center"><div class="data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">3</div></a></div><div class="data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a></div><div class="data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">梓见</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">《僵尸危机：Unity重置版》开发全纪录</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-09-26T19:06:21.000Z" title="发表于 2022-09-27 03:06:21">2022-09-27</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-09-27T12:05:27.334Z" title="更新于 2022-09-27 20:05:27">2022-09-27</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="《僵尸危机：Unity重置版》开发全纪录"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p><a target="_blank" rel="noopener" href="https://tzj2022.xyz/ZombieCrisis-Re/">游玩地址</a><br><a target="_blank" rel="noopener" href="https://github.com/uestctangzijian/ZombieCrisis_Src">项目源码</a></p>
<h1 id="地图设计"><a href="#地图设计" class="headerlink" title="地图设计"></a>地图设计</h1><p>本项目实现了笔者最喜爱的一张地图MAXEY。这张地图由一些长方形的墙体和锥形的墙角组成，Unity已经提供了立方体cube，可以用来做墙面，而墙角顶部的四棱锥需要通过3D建模软件（笔者使用的是blender）生成后导入到unity中。这里也用代码渲染四棱锥，但是如果几何体越来越复杂，使用建模软件无疑是更加合理的一种方式。地图的效果如下。</p>
<p><img src="/images/map.png"></p>
<h1 id="玩家设计"><a href="#玩家设计" class="headerlink" title="玩家设计"></a>玩家设计</h1><p>玩家的行为主要有以下三个：行走，攻击和生命值。</p>
<p><img src="/images/playerAction.png"></p>
<h2 id="玩家行走"><a href="#玩家行走" class="headerlink" title="玩家行走"></a>玩家行走</h2><p>游戏接收方向键的输入，向上、下、左、右、左上、左下、右上、右下八个方向移动，上下左右好实现，如何使玩家往斜向的45°移动呢？根据数学知识，当垂直方向和水平方向的向量大小相等时，向量和的方向指向45°。</p>
<p><img src="/images/vectorPlus.png"></p>
<p>如上图，我们可以在接收到上键&#x2F;下键的输入时，将垂直方向的分量设为1&#x2F;-1，接受到左右键的输入时，将水平方向的分量设为1&#x2F;-1，这样最后的方向向量vector3(1&#x2F;-1, 0, 1&#x2F;-1)一定朝斜向45°方向，再乘上速度值v即为最终的速度向量。<br>Unity中可以直接通过GetAxisRaw函数获取到正规化后的值：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">float</span> horizontal = Input.GetAxisRaw(<span class="string">&quot;Horizontal&quot;</span>);</span><br><span class="line"><span class="built_in">float</span> vertical = Input.GetAxisRaw(<span class="string">&quot;Vertical&quot;</span>);</span><br><span class="line"></span><br><span class="line">Vector3 direction = <span class="keyword">new</span> Vector3(horizontal, <span class="number">0</span>, vertical);</span><br><span class="line">Vector3 velocity = direction * speed;</span><br><span class="line"></span><br><span class="line">velocity = Vector3.ClampMagnitude(velocity, speed);</span><br><span class="line">rb.velocity = velocity;</span><br></pre></td></tr></table></figure>

<h2 id="玩家攻击"><a href="#玩家攻击" class="headerlink" title="玩家攻击"></a>玩家攻击</h2><p>游戏接收空格键输入，当空格键按下时，判断是否可以射击。射击要判断攻击间隔、子弹数是否满足要求。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">LateUpdate</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    shotBetweenTime -= Time.deltaTime;</span><br><span class="line">    <span class="comment">// 射击</span></span><br><span class="line">    <span class="keyword">if</span> (isFiring)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (shotBetweenTime &lt;= <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 重置计时器</span></span><br><span class="line">            shotBetweenTime = currentWeapon.TimeBetweenShots;</span><br><span class="line">            currentWeapon.Fire();</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 子弹用尽</span></span><br><span class="line">            <span class="keyword">if</span> (currentWeapon.CurAmmo == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 切换成Pistol</span></span><br><span class="line">                onAmmoRunout?.Invoke(currentWeapon);</span><br><span class="line">                shotBetweenTime = currentWeapon.TimeBetweenShots;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (shotBetweenTime &lt;= <span class="number">0</span>) shotBetweenTime = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="生命管理"><a href="#生命管理" class="headerlink" title="生命管理"></a>生命管理</h2><p>生命管理处理玩家收到伤害和收到治疗的逻辑。<br>玩家收到攻击时，首先需要扣除血量，在地上生成一个血迹，并有一个后退的效果。当血量小于0时，玩家将会死亡。<br>玩家拾取到治疗物品时，生命值增加。</p>
<h3 id="伤害及治疗"><a href="#伤害及治疗" class="headerlink" title="伤害及治疗"></a>伤害及治疗</h3><p>增减health的值即可。</p>
<h3 id="血渍效果"><a href="#血渍效果" class="headerlink" title="血渍效果"></a>血渍效果</h3><p>我们在Quad上贴一个血迹的material来实现血渍效果。<br><img src="/images/blood.png"><br>当玩家收到攻击时，初始化一个血渍的prefab，高度设置为比地面略高一点点，大小和旋转在一定范围内随机。<br>每个血渍会在生成的60s后销毁，避免内存的过度膨胀。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">spawnBlood</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    Vector3 spawnPos = transform.position;</span><br><span class="line">    spawnPos.y = UnityEngine.Random.Range(<span class="number">0.01f</span>, <span class="number">0.05f</span>);</span><br><span class="line">    <span class="built_in">float</span> zRotation = UnityEngine.Random.Range(<span class="number">0f</span>, <span class="number">180f</span>);</span><br><span class="line">    Transform bloodTrans = Instantiate(bloodPrefab, spawnPos, Quaternion.Euler(<span class="number">90f</span>, <span class="number">0</span>, zRotation)).transform;</span><br><span class="line">    bloodTrans.parent = GameObject.Find(<span class="string">&quot;Bloods&quot;</span>).transform;</span><br><span class="line">    Vector3 randomizedScale = bloodTrans.transform.localScale;</span><br><span class="line">    randomizedScale.x *= UnityEngine.Random.Range(<span class="number">1.0f</span>, <span class="number">1.2f</span>);</span><br><span class="line">    randomizedScale.y *= UnityEngine.Random.Range(<span class="number">1.0f</span>, <span class="number">1.2f</span>);</span><br><span class="line">    bloodTrans.transform.localScale = randomizedScale;</span><br><span class="line"></span><br><span class="line">    Destroy(bloodTrans.gameObject, <span class="number">60f</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="击退效果"><a href="#击退效果" class="headerlink" title="击退效果"></a>击退效果</h3><p>在玩家的刚体组件上施加一个来自攻击方向的力，并调整玩家的朝向为攻击的相反方向。<br>此处力的模式为Impulse，即瞬时力。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">knockback</span>(<span class="params">Vector3 attackForce</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    rb.AddForce(attackForce, ForceMode.Impulse);</span><br><span class="line">    transform.LookAt(transform.position - attackForce.normalized);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="敌人设计"><a href="#敌人设计" class="headerlink" title="敌人设计"></a>敌人设计</h1><p>与玩家一样，敌人也分为移动，攻击，生命管理三个部分。</p>
<h2 id="敌人移动"><a href="#敌人移动" class="headerlink" title="敌人移动"></a>敌人移动</h2><p>游戏中敌人需要始终追随玩家对象，同时避开场景中的各种障碍。<br>Unity提供了一个导航系统Navigation AI，它的工作原理是：<br>游戏开始前，它会根据场景中的导航平面以及平面上的障碍生成一个导航网格NavMesh，如下图中的蓝色区域，表示物体可以行走的区域；游戏运行时，我们给要导航的对象NavMeshAgent一个目标地点，它会在NavMesh上生成一条从当前位置到目标位置的路线（这条路线在游戏中不可见，本项目中对它进行了可视化，方便调试），对象会按照这条路线移动。<br><img src="/images/NavMeshPath.png"><br>本项目使用该组件实现了一个基础的自动寻路功能，首先将场景中的建筑设置为Navigation static，为Enemy绑定NavMeshAgent并调整一些参数，然后在Navigation中点击Bake即可渲染NavMesh，在脚本中还需要将Agent的Destination设置为玩家的位置。</p>
<h2 id="敌人攻击"><a href="#敌人攻击" class="headerlink" title="敌人攻击"></a>敌人攻击</h2><p>敌人有普通僵尸与红色僵尸（boss）两种类型，两种僵尸的攻击方式有所不同。所以可以定义一个基类EnemyAttack，两种僵尸攻击脚本分别为ZombieAttack和BossAttack，继承自EnemyAttack。<br><img src="/images/EnemyAttack.png"></p>
<h3 id="普通僵尸"><a href="#普通僵尸" class="headerlink" title="普通僵尸"></a>普通僵尸</h3><p>僵尸的攻击有两个条件：一是玩家处于攻击范围内，二是面向玩家。<br>玩家和僵尸的距离可以通过两个位置坐标计算，与设定的攻击范围比较大小。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">float</span> distance = Vector3.Distance(transform.position, target.transform.position);</span><br><span class="line"><span class="built_in">bool</span> isInAttackRange = distance &lt;= attackRange;</span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://docs.unity3d.com/ScriptReference/Physics.Raycast.html">Physic.Raycast</a>可以用来发射一条射线，检查射线与玩家有无交点，即可判断僵尸是否面对玩家。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="built_in">bool</span> <span class="title">isFaceToTarget</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    LayerMask mask = ~(<span class="number">1</span> &lt;&lt; LayerMask.NameToLayer(<span class="string">&quot;Fireball&quot;</span>));</span><br><span class="line">    <span class="keyword">if</span> (Physics.Raycast(transform.position, transform.forward, <span class="keyword">out</span> RaycastHit hit, attackRange, mask))</span><br><span class="line">    &#123;</span><br><span class="line">        attackDiretion = transform.forward;</span><br><span class="line">        <span class="keyword">return</span> hit.transform.CompareTag(<span class="string">&quot;Player&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当以上两个条件同时满足时，禁用agent组件，并调用子类中的attack方法，普通僵尸的攻击方式为伤害面前的一片球形区域，可以使用<a target="_blank" rel="noopener" href="https://docs.unity3d.com/ScriptReference/Physics.OverlapSphere.html">Physics.OverlapSphere</a>。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">attack</span>(<span class="params">Vector3 attackDirection</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Collider[] hitObjects = Physics.OverlapSphere(damageArea.position, impactRadius);</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; hitObjects.Length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (hitObjects[i].CompareTag(<span class="string">&quot;Player&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            hitObjects[i].transform.GetComponent&lt;PlayerHealth&gt;().TakeDamage(attackDamage, attackDiretion * impact);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="红色僵尸（Boss）"><a href="#红色僵尸（Boss）" class="headerlink" title="红色僵尸（Boss）"></a>红色僵尸（Boss）</h3><p>红色僵尸的攻击条件与普通僵尸相同，需要注意的一点是，在检查是否面向玩家时，我们不希望火球阻挡Raycast的检测，所以在调用Raycast时，传入火球的layer作为LayerMask，使其忽略火球对象。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LayerMask mask = ~(<span class="number">1</span> &lt;&lt; LayerMask.NameToLayer(<span class="string">&quot;Fireball&quot;</span>));</span><br></pre></td></tr></table></figure>
<p>红色僵尸攻击方式为发射一个火球。我们创建好火球的预设，在Boss攻击时初始化该预设，给它设置初速度，伤害，方向等。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">attack</span>(<span class="params">Vector3 attackDirection</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    BossFireball fireball = Instantiate(projectilePrefab, damageArea.position, Quaternion.identity).GetComponent&lt;BossFireball&gt;();</span><br><span class="line">    fireball.Speed = projectileSpeed;</span><br><span class="line">    fireball.Damage = attackDamage;</span><br><span class="line">    fireball.transform.localScale = fireball.transform.localScale * projectileScale;</span><br><span class="line">    fireball.Direction = attackDirection;</span><br><span class="line">    fireball.Impact = impact;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当有其它物体进入到火球的Collider时，检查它是否为玩家对象，是则调用玩家的生命值脚本使其收到伤害。之后销毁火球对象。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnCollisionEnter</span>(<span class="params">Collision collision</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    PlayerHealth health = collision.transform.GetComponent&lt;PlayerHealth&gt;();</span><br><span class="line">    <span class="keyword">if</span> (health != <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        health.TakeDamage(damage, direction * impact);</span><br><span class="line">    &#125;</span><br><span class="line">    Destroy(gameObject);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="生命管理-1"><a href="#生命管理-1" class="headerlink" title="生命管理"></a>生命管理</h2><p>与玩家的生命值管理基本一致，后续可以考虑合成为一个脚本。</p>
<h1 id="动画系统"><a href="#动画系统" class="headerlink" title="动画系统"></a>动画系统</h1><p>本项目为玩家和敌人都设计了动画，使用的是新版动画系统Mecanim，玩家和敌人的动画实现相似，这里以敌人的动画为例。</p>
<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="Animator组件"><a href="#Animator组件" class="headerlink" title="Animator组件"></a>Animator组件</h3><p>一个游戏对象想要拥有动画，首先需要添加Animator组件，如下图，可以使用Inspector中的Add Compenent添加。<br><img src="/images/AnimatorComponent.png"></p>
<h3 id="Animator-Controller动画控制器"><a href="#Animator-Controller动画控制器" class="headerlink" title="Animator Controller动画控制器"></a>Animator Controller动画控制器</h3><p>如上图，Animator组件的第一个参数就是Animator Controller，一个Animator组件对应一个Animator Controller。可以在“Animator”窗口中查看某个Animator Controller。Animator Controller控制着该对象动画的执行条件，动画间的切换等。如下图，本游戏为敌人设计了idle，walk，attack，isAttacked，die，dead几个状态，状态间的箭头表示一个状态可以在某种条件下切换为另一个状态。<br><img src="/images/AnimatorController.png"></p>
<h3 id="Animation-x2F-Animation-Clip动画片段"><a href="#Animation-x2F-Animation-Clip动画片段" class="headerlink" title="Animation&#x2F;Animation Clip动画片段"></a>Animation&#x2F;Animation Clip动画片段</h3><p>上图中的每个状态对应着一个动画片段，这个动画片段就是Animation Clip，可以在“Animation”窗口中编辑动画片段。注意：<strong>如果想要编辑动画，必须要在Hierachy窗口中选中该Animator所在的对象</strong>。</p>
<h2 id="动画状态转换"><a href="#动画状态转换" class="headerlink" title="动画状态转换"></a>动画状态转换</h2><p>Animator窗口展示的图也叫作动画状态机，下面介绍动画如何从一个状态切换成另一个状态。<br>下面的所有状态切换均取消HasExitTime，且动画可以立即切换成另一个状态。<br>idle&lt;-&gt;walk：行走动画取决于玩家的速度，当玩家速度大于0.01时进入行走状态，反之则恢复成idle，所以添加一个float型参数speed，在代码中设置其值为agent的velocity。<br>idle&lt;-&gt;attack：添加一个bool型参数attack，在代码调用attack的时候把这个参数设为true，反之设为false。<br>anystate-&gt;isAttacked：添加一个trigger型参数isAttacked，在敌人收到伤害时触发此trigger。<br>isattacked-&gt;die：添加一个trigger型参数die，在敌人血量为0时触发此trigger。<br>die-&gt;dead：dead动画让敌人保持躺的状态直到销毁，所以在触发die动画的同时将dead设为true</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Die</span>(<span class="params"><span class="built_in">int</span> health</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    animator.SetTrigger(<span class="string">&quot;die&quot;</span>);</span><br><span class="line">    animator.SetBool(<span class="string">&quot;dead&quot;</span>, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="动画切片制作"><a href="#动画切片制作" class="headerlink" title="动画切片制作"></a>动画切片制作</h2><p>在完成动画状态机的设计后，我们可以制作动画切片了。Unity自带Animation工具就可以制作一些简单的关键帧动画。如图3.4所示，点击左侧的Add Property后可以看到，unity可以对游戏对象的Transform，Rigidbody，Collider，Script和Animator作属性变换。<br><img src="/images/Animation.png"><br>在我们的项目中，敌人的行走，攻击，死亡等动画只需要对敌人的肢体作旋转动画即可。以walk动画为例，我们添加5个关键帧，设置好每一帧手臂和腿的旋转角度，unity会在关键帧之间插值，形成行走动画的效果。<br><img src="/images/WalkAnimation.gif"></p>
<h1 id="敌人生成器"><a href="#敌人生成器" class="headerlink" title="敌人生成器"></a>敌人生成器</h1><p>在做好单个敌人的prefab之后，我们需要在地图上自动的生成大量敌人，这个操作通过脚本实现。<br>我们的需求是，僵尸能够一波一波生成，每波僵尸可以指定其类型（普通僵尸或boss），数量，生成间隔，所以可以定义一个可序列化的结构体。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">EnemyWave</span> &#123;</span><br><span class="line">    [<span class="meta">SerializeField</span>]</span><br><span class="line">    <span class="keyword">private</span> EnemyType enemyType;    <span class="comment">// 僵尸类型</span></span><br><span class="line">    [<span class="meta">SerializeField</span>]</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> amount;             <span class="comment">// 每波要生成的僵尸数</span></span><br><span class="line">    [<span class="meta">SerializeField</span>]</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">float</span> timeBetweenSpawn; <span class="comment">// 生成间隔</span></span><br><span class="line">    [<span class="meta">HideInInspector</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Count = <span class="number">0</span>;           <span class="comment">// 已经刷新的僵尸数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于每个生成点而言，它可以生成多波僵尸，所以需要有一个EnemyWave的数组。<br>生成敌人时，我们检查该生成点拥有的所有僵尸波数是否都已生成完，如果没有，我们生成当前波数的僵尸，并让Count自增。当Count已经到达当前波数的amount时，再生成下一波僵尸。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (hasFinishedSpawning) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (enmeyWaves[currentWaveIndex].WaveFinished)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (currentWaveIndex &lt; enmeyWaves.Count - <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            currentWaveIndex++;</span><br><span class="line">            countdown = enmeyWaves[currentWaveIndex].TimeBetweenSpawn;</span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            hasFinishedSpawning = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    countdown -= Time.deltaTime;</span><br><span class="line">    EnemyWave wave = enmeyWaves[currentWaveIndex];</span><br><span class="line">    <span class="keyword">if</span> (countdown &lt;= <span class="number">0</span> &amp;&amp; !wave.WaveFinished &amp;&amp; enemyManager.canSpawnNewEnemy)</span><br><span class="line">    &#123;</span><br><span class="line">        GameObject go = Instantiate(GetEnemyPrefabByType(wave.EnemyType)) <span class="keyword">as</span> GameObject;</span><br><span class="line">        <span class="comment">//go.transform.position = transform.position;</span></span><br><span class="line">        go.transform.parent = transform;</span><br><span class="line">        go.transform.rotation = transform.localRotation;</span><br><span class="line"></span><br><span class="line">        EnemyController enemy = go.GetComponent&lt;EnemyController&gt;();</span><br><span class="line">        <span class="comment">// 用warp设置初始位置，可以避免瞬移问题</span></span><br><span class="line">        <span class="comment">// https://answers.unity.com/questions/1830969/navmeshagentwarp-meaning.html</span></span><br><span class="line">        enemy.agent.Warp(transform.position);</span><br><span class="line">        enemy.enemyManager = enemyManager;</span><br><span class="line">        enemy.pickupGenerator = pickupGenerator;</span><br><span class="line">        enemy.Target = player;</span><br><span class="line">        enemy.type = wave.EnemyType;</span><br><span class="line">        wave.Count++;</span><br><span class="line">        countdown = wave.TimeBetweenSpawn;</span><br><span class="line"></span><br><span class="line">        enemyManager.AddEnemy(enemy.gameObject);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在初始化僵尸的位置时，最好使用Agent.Warp，不然可能会出现<a target="_blank" rel="noopener" href="https://answers.unity.com/questions/1830969/navmeshagentwarp-meaning.html">瞬移问题</a>。</p>
<p>这里再引入一个EnemyManager，用来管理地图上所有已经生成的敌人，控制地图上敌人的总数。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">EnemyManager</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;GameObject&gt; enemies;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> maxAmountOfZombies;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        enemies = <span class="keyword">new</span> List&lt;GameObject&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">AddEnemy</span>(<span class="params">GameObject enemy</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        enemies.Add(enemy);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">RemoveEnemy</span>(<span class="params">GameObject enemy</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        enemies.Remove(enemy);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> CurrentEnemiesCount</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> enemies.Count;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">bool</span> canSpawnNewEnemy</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> enemies.Count &lt; maxAmountOfZombies;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="武器系统"><a href="#武器系统" class="headerlink" title="武器系统"></a>武器系统</h1><p>武器系统是整个游戏的核心。原版游戏提供了十种武器，分别是Pistol手枪，UZI冲锋枪，Shotgun霰弹枪，Barrel汽油桶，Grenade手榴弹，FakeWall假墙，Claymore地雷，Rocket火箭炮，ChargePack遥控炸弹，Railgun镭射枪，本项目中将它们一一实现。</p>
<h2 id="设计思路"><a href="#设计思路" class="headerlink" title="设计思路"></a>设计思路</h2><p>在设计武器系统之前，我们可以将以上十种武器进行归类，找出它们的共性。<br><img src="/images/WeaponClassfication.png"><br>为何要归类？十种武器是一个不小数目，对它进行归类后我们可以抽出一些接口，基类等，从而减少代码量，提高可维护性。<br>就本项目而言，对于激光类武器，我们需要用LineRenderer组件实现枪口射线效果，那么就可以抽出基类RayCastBaseWeapon，让它持有LineRenderer，父类包含一些Raycast逻辑，子类再定制化操作。<br>对于爆炸类武器，可以抽出IExplosive接口，表示一个可以爆炸的对象。在游戏中，爆炸物爆炸时需要引爆周围所有可爆炸的对象。所以在爆炸时判断周围object是否实现IExplosive接口即可。<br>对于放置类武器，需要分开设计武器生成器和武器本身。拿油桶举例，需要有BarrelGenrator和Barrel两个类，BarrelGenrator作为基类Weapon的子类，负责生成Barrel。Barrel实现IExplosive接口，作为可爆炸的对象。<br>下图是整个武器系统的类图：<br><img src="/images/WeaponClassGraph.png"></p>
<h2 id="Weapon基类"><a href="#Weapon基类" class="headerlink" title="Weapon基类"></a>Weapon基类</h2><p>首先我们将十种武器类型定义成枚举。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="built_in">enum</span> WeaponType</span><br><span class="line">&#123;</span><br><span class="line">    pistol = <span class="number">0</span>,     <span class="comment">// 手枪</span></span><br><span class="line">    uzi,        <span class="comment">// 冲锋枪</span></span><br><span class="line">    shotgun,    <span class="comment">// 霰弹枪</span></span><br><span class="line">    barrel,     <span class="comment">// 油桶</span></span><br><span class="line">    grenade,    <span class="comment">// 手榴弹</span></span><br><span class="line">    fakeWalls,  <span class="comment">// 假墙</span></span><br><span class="line">    claymore,   <span class="comment">// 炸弹</span></span><br><span class="line">    rocket,     <span class="comment">// 火箭炮</span></span><br><span class="line">    chargepack, <span class="comment">// 遥控炸弹</span></span><br><span class="line">    railgun     <span class="comment">// 镭射枪</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>之后再定义一个结构体WeaponDefinition，包含一个武器的各种属性，包括武器类型，武器名称，伤害，射速，子弹容量等等。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">System.Serializable</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">WeaponDefinition</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> WeaponType type = WeaponType.pistol;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> index;</span><br><span class="line">    <span class="keyword">public</span> Vector3 pos;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> name;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> damage;              <span class="comment">// 伤害</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> FireRate;              <span class="comment">// 每分钟射出的子弹数 表示射速</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> ammoCapacity;          <span class="comment">// 弹夹容量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> shootingRange;       <span class="comment">// 攻击距离</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> velocity;            <span class="comment">// 子弹速度</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Weapon基类可以设计的尽可能简单，包含武器定义、子弹数等属性，以及射击，填充子弹的方法即可。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">Weapon</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">SerializeField</span>]</span><br><span class="line">    <span class="keyword">protected</span> WeaponDefinition def;</span><br><span class="line">    <span class="keyword">protected</span> <span class="built_in">int</span> curAmmo; <span class="comment">// 当前子弹数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">float</span> timeBetweenShots; <span class="comment">// 攻击间隔</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        RestockAmmo();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">Fire</span>()</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> WeaponDefinition <span class="title">GetWeaponDef</span>()</span> =&gt; def;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 加满子弹</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">RestockAmmo</span>()</span> =&gt; curAmmo = def.ammoCapacity;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Pistol-手枪"><a href="#Pistol-手枪" class="headerlink" title="Pistol 手枪"></a>Pistol 手枪</h2><p>如上文所述，手枪包含一个LineRenderer。当手枪开火时，从枪口向正前方发射射线，射线的起点为枪口的位置，射线的终点取决于射击范围内是否与物体相交。这里同样可以使用Physics.Raycast作光线投射，如果Raycast检测到了物体，则将LineRenderer的终点设置为碰撞点，反之则设置为攻击的最大距离。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (Physics.Raycast(ray, <span class="keyword">out</span> hit, def.shootingRange)) &#123;</span><br><span class="line">    Transform rootT = hit.collider.gameObject.transform;</span><br><span class="line">    GameObject otherGO = rootT.gameObject;</span><br><span class="line">    <span class="keyword">if</span> (otherGO.tag == <span class="string">&quot;Enemy&quot;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        EnemyController enemy = otherGO.GetComponent&lt;EnemyController&gt;();</span><br><span class="line">        enemy.TakeDamage(def.damage, ray.direction * attackForce);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (otherGO.tag == <span class="string">&quot;Barrel&quot;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Barrel barrel = otherGO.transform.GetComponent&lt;Barrel&gt;();</span><br><span class="line">        <span class="keyword">if</span> (barrel != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            barrel.Explode();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (otherGO.tag == <span class="string">&quot;FakeWall&quot;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        FakeWall fakewall = otherGO.transform.parent.GetComponent&lt;FakeWall&gt;();</span><br><span class="line">        <span class="keyword">if</span> (fakewall != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            fakewall.TakeDamage(def.damage);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    gunLine.SetPosition(<span class="number">1</span>, hit.point);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (gunLine != <span class="literal">null</span>)</span><br><span class="line">&#123;</span><br><span class="line">    gunLine.SetPosition(<span class="number">1</span>, ray.origin + ray.direction * def.shootingRange);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果射线击中了敌人，扣除敌人的血量；如果击中了油桶，使它爆炸；如果击中了假墙，扣除假墙的生命值。</p>
<h2 id="UZI-冲锋枪"><a href="#UZI-冲锋枪" class="headerlink" title="UZI 冲锋枪"></a>UZI 冲锋枪</h2><p>冲锋枪的逻辑与手枪基本一致，区别是冲锋枪的射速更快。</p>
<h2 id="Shotgun-霰弹枪"><a href="#Shotgun-霰弹枪" class="headerlink" title="Shotgun 霰弹枪"></a>Shotgun 霰弹枪</h2><p>霰弹枪向前方发射多条射线，所以它与前两种枪械的最大区别是LineRenderer的个数。<br>霰弹枪需要传入攻击范围，从枪口在攻击范围内发射若干条射线，我们对每条射线分别作Raycast。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Fire</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    EnableLineRenderers(<span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; lineRenderers.Length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        Vector3 direction;</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            direction = muzzleTrans.forward;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            direction = Quaternion.AngleAxis(-spreadAngle / <span class="number">2.0f</span>, Vector3.up) * muzzleTrans.forward;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i == <span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            direction = Quaternion.AngleAxis(-spreadAngle / <span class="number">4.0f</span>, Vector3.up) * muzzleTrans.forward;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i == <span class="number">3</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            direction = Quaternion.AngleAxis(spreadAngle / <span class="number">4.0f</span>, Vector3.up) * muzzleTrans.forward;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i == <span class="number">4</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            direction = Quaternion.AngleAxis(spreadAngle / <span class="number">2.0f</span>, Vector3.up) * muzzleTrans.forward;</span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            direction = Vector3.zero;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        lineRenderers[i].SetPosition(<span class="number">0</span>, muzzleTrans.position);</span><br><span class="line">        ShootWithRay(muzzleTrans.position, direction, i);</span><br><span class="line">    &#125;</span><br><span class="line">    CurAmmo--;</span><br><span class="line">    StartCoroutine(DisableLineRenderersAfterDelay());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ShootWithRay</span>(<span class="params">Vector3 origin, Vector3 direction, <span class="built_in">int</span> index</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (Physics.Raycast(origin, direction, <span class="keyword">out</span> hitInfos[index], def.shootingRange))</span><br><span class="line">    &#123;</span><br><span class="line">        lineRenderers[index].SetPosition(<span class="number">1</span>, hitInfos[index].point);</span><br><span class="line">        HitObject(hitInfos[index].transform, def.damage);</span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        lineRenderers[index].SetPosition(<span class="number">1</span>, origin + direction * def.shootingRange);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Barrel-汽油桶"><a href="#Barrel-汽油桶" class="headerlink" title="Barrel 汽油桶"></a>Barrel 汽油桶</h2><p>汽油桶属于放置类武器，它包含一个生成器BarrelGenerator，攻击键按下时，BarrelGenerator初始化一个Barrel对象。<br><strong>BarrelGenerator</strong></p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// BarrelGenerator.cs</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Fire</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    Transform spawnerTrans = getValidSpawnerTrans();</span><br><span class="line">    <span class="keyword">if</span> (getValidSpawnerTrans() == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    GameObject go = Instantiate(BarrelPrefab) <span class="keyword">as</span> GameObject;</span><br><span class="line">    go.transform.position = spawnerTrans.position;</span><br><span class="line">    go.transform.parent = GameObject.Find(<span class="string">&quot;Building/Barrels&quot;</span>).transform;</span><br><span class="line">    Barrel barrel = go.GetComponent&lt;Barrel&gt;();</span><br><span class="line">    barrel.damage = def.damage;</span><br><span class="line">    barrel.onBarrelLeavePlayer += changeOverlap;</span><br><span class="line">    <span class="keyword">if</span> (!HasUnlimitedAmmo) CurAmmo--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个有两个问题需要注意：</p>
<ol>
<li>原作中油桶的生成位置并不完全与玩家的位置重合，而是生成在玩家的前后左右偏移一点的位置，如下图。这就带来一个问题，当玩家的附近有物体时，我们需要找到一个足够大小放置油桶的位置来初始化position，如果找不到这样的位置，则不生成油桶。<br><img src="/images/BarrelGenPos.png"><br>具体方案是在玩家的四周（左上，左下，右上，右下）预设好四个位置，对于每个位置，依次判断以它为中心的球形区域有没有障碍物，如果有则在该位置生成油桶。<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// BarrelGenerator.cs</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Transform <span class="title">getValidSpawnerTrans</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">foreach</span> (Transform st <span class="keyword">in</span> spawnerTrans)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (isValidTrans(st))</span><br><span class="line">            <span class="keyword">return</span> st;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="built_in">bool</span> <span class="title">isValidTrans</span>(<span class="params">Transform trans</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Collider[] hitColliders = Physics.OverlapSphere(trans.position, colliderRadius, ~excludeLayer);</span><br><span class="line">    <span class="keyword">if</span> (hitColliders.Length &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>原作中玩家刚放置油桶时身体有一部分与油桶重合，如下图，此时玩家可以在油桶内移动。当玩家走出油桶后不可以再与油桶重合。<br><img src="/images/PlayerBarrel.png"><br>所以在初始化油桶对象时，需要关闭油桶的Collider，当玩家距离油桶中心一定距离后，再激活Collider。另外，当玩家处于油桶碰撞体内时，不可以放置油桶。<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// BarrelGenerator.cs</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Fire</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (isOverlapBarrel) <span class="keyword">return</span>; <span class="comment">// 当玩家与油桶重合时，返回</span></span><br><span class="line">    Transform spawnerTrans = getValidSpawnerTrans();</span><br><span class="line">    <span class="keyword">if</span> (getValidSpawnerTrans() == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    isOverlapBarrel = <span class="literal">true</span>;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 传入回调方法</span></span><br><span class="line">    barrel.onBarrelLeavePlayer += changeOverlap;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">changeOverlap</span>(<span class="params">Barrel barrel</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    isOverlapBarrel = <span class="literal">false</span>; <span class="comment">// 重置标志位</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Barrel.c#</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 当玩家离开油桶时，激活Collider</span></span><br><span class="line">    <span class="keyword">if</span> (col.enabled) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">float</span> distance = Vector3.Distance(gameObject.transform.position, player.position);</span><br><span class="line">    <span class="keyword">if</span> (distance &gt; distanceToPlayer &amp;&amp; !hasLeavePlayer)</span><br><span class="line">    &#123;</span><br><span class="line">        col.enabled = <span class="literal">true</span>;</span><br><span class="line">        onBarrelLeavePlayer?.Invoke(<span class="keyword">this</span>);</span><br><span class="line">        hasLeavePlayer = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<strong>Barrel</strong><br>当有弹丸类型的物体进入油桶的Collider时，调用自身的IExplosive接口的Explode方法，关闭油桶对象的MeshRender和Collider，播放爆炸粒子特效，并对球形范围的对象造成伤害。<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnCollisionEnter</span>(<span class="params">Collision collision</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// explosionInducingLayers用来筛选弹丸类的物体</span></span><br><span class="line">    <span class="keyword">if</span> (explosionInducingLayers == (explosionInducingLayers | (<span class="number">1</span> &lt;&lt; collision.gameObject.layer)))</span><br><span class="line">    &#123;</span><br><span class="line">        Explode();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">explode</span>(<span class="params">Transform trans</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    GameObject explosionEffect = trans.Find(<span class="string">&quot;BigExplosion&quot;</span>).gameObject;</span><br><span class="line">    explosionEffect.gameObject.SetActive(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    Collider[] hitColliders = Physics.OverlapSphere(trans.position, explosionRadius);</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; hitColliders.Length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        EnemyController enemy = hitColliders[i].GetComponent&lt;EnemyController&gt;();</span><br><span class="line">        <span class="keyword">if</span> (enemy != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            Vector3 direction = trans.position - enemy.gameObject.transform.position;</span><br><span class="line">            enemy.TakeDamage(damage, direction * impact);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (hitColliders[i].gameObject.GetComponent&lt;MonoBehaviour&gt;() <span class="keyword">is</span> IExplosive explosive)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (explosive != <span class="keyword">this</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    explosive.Explode();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (hitColliders[i].transform.CompareTag(<span class="string">&quot;FakeWall&quot;</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                FakeWall fakewall = hitColliders[i].transform.parent.GetComponent&lt;FakeWall&gt;();</span><br><span class="line">                <span class="keyword">if</span> (fakewall != <span class="literal">null</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    fakewall.TakeDamage(damage);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    AudioManager.Instance.Play(<span class="string">&quot;Explosion&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="Genrade-手榴弹"><a href="#Genrade-手榴弹" class="headerlink" title="Genrade 手榴弹"></a>Genrade 手榴弹</h2><p><strong>GrenadeGenerator</strong><br>手榴弹的投掷有一个初速度，初速度取决于攻击键的按键时长，所以我们需要记录KeyCode.Space的按下时间。在GetKeyDown记录起始时间，GetKeyUp时记录结束时间，将时长传给GrenadeGenerator。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// playerAttack</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 射击</span></span><br><span class="line">    <span class="keyword">if</span> (Input.GetKeyDown(KeyCode.Space))</span><br><span class="line">    &#123;</span><br><span class="line">        startTime = Time.time;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">if</span> (Input.GetKeyUp(KeyCode.Space))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 手榴弹在攻击键抬起时扔出</span></span><br><span class="line">        <span class="keyword">if</span> (currentWeapon.GetWeaponDef().type == WeaponType.grenade)</span><br><span class="line">        &#123;</span><br><span class="line">            GrenadeGenerator gg = currentWeapon <span class="keyword">as</span> GrenadeGenerator;</span><br><span class="line">            gg.Throw(Time.time - startTime);</span><br><span class="line">            OnWeaponShot?.Invoke(currentWeapon, currentWeapon.CurAmmo);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据按键时长算出初速度，传给Genrade的刚体组件。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Throw</span>(<span class="params"><span class="built_in">float</span> pressDuration</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">float</span> velocity = pressDuration * velocityRate;</span><br><span class="line">    <span class="keyword">if</span> (velocity &lt; minVelocity) velocity = minVelocity;</span><br><span class="line">    <span class="keyword">if</span> (velocity &gt; maxVelocity) velocity = maxVelocity;</span><br><span class="line"></span><br><span class="line">    GameObject go = Instantiate(GrenadePrefab) <span class="keyword">as</span> GameObject;</span><br><span class="line">    go.transform.position = spawnerPos.position;</span><br><span class="line"></span><br><span class="line">    Grenade grenade = go.GetComponent&lt;Grenade&gt;();</span><br><span class="line">    grenade.Damage = def.damage;</span><br><span class="line">    grenade.Speed = transform.forward * velocity;</span><br><span class="line">    <span class="keyword">if</span> (!HasUnlimitedAmmo) CurAmmo--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Grenade</strong><br>在Grenade创建3s后调用Explode，可以用StartCoroutine或者Invoke。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    rb.velocity = speed;</span><br><span class="line">    StartCoroutine(explodeAfterDalay(explodeDalay));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> IEnumerator <span class="title">explodeAfterDalay</span>(<span class="params"><span class="built_in">float</span> time = <span class="number">3f</span></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (time == <span class="number">0.0f</span>) <span class="keyword">yield</span> <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="function"><span class="keyword">yield</span> <span class="keyword">return</span> <span class="keyword">new</span> <span class="title">WaitForSeconds</span>(<span class="params">time</span>)</span>;</span><br><span class="line">    Explode();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>爆炸的实现与油桶一致。</p>
<h2 id="FakeWall-假墙"><a href="#FakeWall-假墙" class="headerlink" title="FakeWall 假墙"></a>FakeWall 假墙</h2><p>FakeWall是玩家在游戏过程中放置的墙体，墙体具有生命值，受到一定攻击后会被破坏，所以叫“Fake”Wall。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TakeDamage</span>(<span class="params"><span class="built_in">int</span> damage</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    health -= damage;</span><br><span class="line">    <span class="keyword">if</span> (health &lt;= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        health = <span class="number">0</span>;</span><br><span class="line">        onDestroy?.Invoke(<span class="keyword">this</span>);</span><br><span class="line">        gameObject.SetActive(<span class="literal">false</span>);</span><br><span class="line">        NavMeshManager.Instance.BakeNavMesh();</span><br><span class="line">        Destroy(gameObject);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Claymore-地雷"><a href="#Claymore-地雷" class="headerlink" title="Claymore 地雷"></a>Claymore 地雷</h2><p>玩家可以在脚下放置Claymore，当敌人走过时，触发爆炸，爆炸有3s延迟。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnTriggerEnter</span>(<span class="params">Collider other</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (isCountDown) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (other.tag == <span class="string">&quot;Enemy&quot;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        isCountDown = <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">// todo: 灯光闪动动画</span></span><br><span class="line">        animator.SetTrigger(<span class="string">&quot;isTrigger&quot;</span>);</span><br><span class="line">        AudioManager.Instance.Play(<span class="string">&quot;MineDetonate&quot;</span>);</span><br><span class="line">        StartCoroutine(ExplodeAfterDelay(explodeDalay));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> IEnumerator <span class="title">ExplodeAfterDelay</span>(<span class="params"><span class="built_in">float</span> time = <span class="number">3f</span></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (time == <span class="number">0f</span>) <span class="keyword">yield</span> <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="function"><span class="keyword">yield</span> <span class="keyword">return</span> <span class="keyword">new</span> <span class="title">WaitForSeconds</span>(<span class="params">time</span>)</span>;</span><br><span class="line">    Explode();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="ChargePack-遥控炸弹"><a href="#ChargePack-遥控炸弹" class="headerlink" title="ChargePack 遥控炸弹"></a>ChargePack 遥控炸弹</h2><p>遥控炸弹的爆炸触发方式是按键，攻击键放置炸弹后，再按一下攻击键即爆炸。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Fire</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (chargepacks.Count == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!isValidPos(spawner)) <span class="keyword">return</span>;</span><br><span class="line">        GameObject go = Instantiate(charegepackPrefab) <span class="keyword">as</span> GameObject;</span><br><span class="line">        go.transform.position = spawner.position;</span><br><span class="line">        Chargepack chargepack = go.GetComponent&lt;Chargepack&gt;();</span><br><span class="line">        chargepack.Damage = def.damage;</span><br><span class="line">        chargepacks.Add(chargepack);</span><br><span class="line">        <span class="keyword">if</span> (!HasUnlimitedAmmo) CurAmmo--;</span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        AudioManager.Instance.Play(<span class="string">&quot;MineDetonate&quot;</span>);</span><br><span class="line">        <span class="keyword">foreach</span> (Chargepack chargepack <span class="keyword">in</span> chargepacks)</span><br><span class="line">        &#123;</span><br><span class="line">            chargepack.Explode();</span><br><span class="line">        &#125;</span><br><span class="line">        chargepacks.Clear();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Rocket-火箭炮"><a href="#Rocket-火箭炮" class="headerlink" title="Rocket 火箭炮"></a>Rocket 火箭炮</h2><p>玩家的火箭炮实现类似于红色僵尸发射的火球。</p>
<h2 id="Railgun-镭射枪"><a href="#Railgun-镭射枪" class="headerlink" title="Railgun 镭射枪"></a>Railgun 镭射枪</h2><p>镭射枪与其它射线武器最大的区别是镭射枪可以对一条线上的敌人造成伤害，而Raycast只会返回相交的第一个物体，如何获取所有相交的对象呢？Physics中提供了另一个方法RaycastAll，RaycastAll返回一个RaycastHit数组，包含所有的交点。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RaycastHit[] hits = Physics.RaycastAll(ray, def.shootingRange)</span><br></pre></td></tr></table></figure>
<p>镭射枪的射线可以穿过敌人，但是不可以穿过墙体，所以我们遍历RaycastHit数组，当遇到tag为Wall的对象时终止循环。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">foreach</span> (RaycastHit h <span class="keyword">in</span> hits)</span><br><span class="line">&#123;</span><br><span class="line">    Transform rootT = h.collider.gameObject.transform;</span><br><span class="line">    GameObject otherGO = rootT.gameObject;</span><br><span class="line">    <span class="keyword">if</span> (otherGO.tag == <span class="string">&quot;Enemy&quot;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        EnemyController enemy = otherGO.GetComponent&lt;EnemyController&gt;();</span><br><span class="line">        enemy.TakeDamage(def.damage, ray.direction * attackForce);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (otherGO.tag == <span class="string">&quot;Barrel&quot;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Barrel barrel = otherGO.transform.GetComponent&lt;Barrel&gt;();</span><br><span class="line">        <span class="keyword">if</span> (barrel != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            barrel.Explode();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (otherGO.tag == <span class="string">&quot;FakeWall&quot;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        FakeWall fakewall = otherGO.transform.parent.GetComponent&lt;FakeWall&gt;();</span><br><span class="line">        <span class="keyword">if</span> (fakewall != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            fakewall.TakeDamage(def.damage);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (otherGO.tag == <span class="string">&quot;Wall&quot;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        hasSetPos1 = <span class="literal">true</span>;</span><br><span class="line">        gunLine.SetPosition(<span class="number">1</span>, h.point);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码看起来没有问题，但是实际运行起来发现射线有时还是能够穿过墙体，对其后的敌人造成伤害。查了一下发现有人遇到了一样的问题，原来Raycast返回的hits数组元素顺序是不确定的，unity官方文档有特别指出这一点：<br><img src="/images/RaycastAll.png"><br>所以在遍历之前必须对RaycastHit数组按照距离从近到远的顺序排序，修改后的代码：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RaycastHit[] hits = Physics.RaycastAll(ray, def.shootingRange).OrderBy(h =&gt;h.distance).ToArray();</span><br></pre></td></tr></table></figure>

<h2 id="武器切换"><a href="#武器切换" class="headerlink" title="武器切换"></a>武器切换</h2><p>游戏处理数字键0-9输入来切换武器，每个数字对应一把武器：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">数字1：Pistol</span><br><span class="line">数字2：UZI</span><br><span class="line">数字3：Shotgun</span><br><span class="line">数字4：Barrel</span><br><span class="line">数字5：Grenade</span><br><span class="line">数字6：Fake Walls</span><br><span class="line">数字7：Claymore</span><br><span class="line">数字8：Rocket</span><br><span class="line">数字9：Chargepack</span><br><span class="line">数字0：Railgun</span><br></pre></td></tr></table></figure>
<p><strong>输入处理</strong><br>用一个for循环判断玩家按的是哪个数字</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="built_in">int</span> i = (<span class="built_in">int</span>)KeyCode.Alpha1; i &lt;= (<span class="built_in">int</span>)KeyCode.Alpha9; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (Input.GetKeyDown((KeyCode)i))</span><br><span class="line">    &#123;</span><br><span class="line">        SwitchWeapon((i - (<span class="built_in">int</span>)KeyCode.Alpha1));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>切换武器</strong><br>切换武器时要判断当前装备的武器是否等于要切换的武器，以及要切换的武器是否有子弹。<br>之后让当前武器指向要切换的武器。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SwitchWeapon</span>(<span class="params"><span class="built_in">int</span> index</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Weapon weapon = inventory.GetWeapon(index);</span><br><span class="line">    <span class="keyword">if</span> (weapon != <span class="literal">null</span> &amp;&amp; attack.GetCurWeapon() != weapon &amp;&amp; weapon.CurAmmo != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        attack.EquipWeapon(weapon);</span><br><span class="line">        onWeaponEquipped?.Invoke(weapon);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="升级系统"><a href="#升级系统" class="headerlink" title="升级系统"></a>升级系统</h1><p>升级系统是整个游戏的灵魂。玩家不断击杀僵尸可以解锁新武器、获得武器提升，从而可以应对更多的僵尸。<br>升级系统与连杀数相关。原作提供了一张升级列表，如下图，列表左边的数字就是连杀数，右边的文本表示该连杀数对应的升级。<br><img src="/images/UpgradeList.png"></p>
<h2 id="连杀数"><a href="#连杀数" class="headerlink" title="连杀数"></a>连杀数</h2><p>玩家每一次击杀僵尸，连杀数就会加1。<br>连杀数会以一定速率减少，连杀数越大减少速度越快。<br>升级系统看的是目前达到的最大连杀数。<br><img src="/images/MultipleKill.gif"></p>
<p><strong>连杀数的减少</strong><br>连杀数减少有一个倒计时，当倒计时等于0时，连杀数减少。连杀数减少的速度与连杀数正相关，所以公式里必须包含当前的连杀数。给出下面公式：<br>$$CurrCountDown &#x3D; InitCountDown * (1 - （Multi - 1） &#x2F; MaxMulti）$$<br>其中CurrCountDown表示当前的倒计时，InitCountDown是我们预设的倒计时，Multi是当前连杀数，MaxMulti限定的最大连杀数。<br>在这个式子中InitCountDown、MaxMulti是常数，所以Multi增加时，乘号右边的式子减小，所以当前的倒计时时间减小，连杀数减少的越来越快。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (multiplier == <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    multiplierDecayCountdown -= Time.deltaTime;</span><br><span class="line">    <span class="keyword">if</span> (multiplierDecayCountdown &lt;= <span class="number">0f</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        multiplierDecayCountdown = <span class="number">0f</span>;</span><br><span class="line">        ResetMultiplierCountdown();</span><br><span class="line">        multiplier--;</span><br><span class="line">        UpdateMultiplierText();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ResetMultiplierCountdown</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    multiplierDecayCountdown = multiplierDecayTime - ((<span class="built_in">float</span>)(multiplier - <span class="number">1</span>) / maxMultiplier * multiplierDecayTime);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>连杀数的增加</strong><br>记一个全局的连杀数，每次有敌人死亡时，让连杀数增加。<br>连杀数增加时，重置倒计时。<br>连杀数增加时，通过delegate将当前连杀数传到升级系统中。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ScoreManager.cs</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">IncreseScore</span>(<span class="params"><span class="built_in">int</span> points</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (multiplier == maxMultiplier)</span><br><span class="line">    &#123;</span><br><span class="line">        ResetMultiplierCountdown();</span><br><span class="line">        score += points * multiplier;</span><br><span class="line">        scoreText.text = score.ToString();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    multiplier++;</span><br><span class="line">    score += points * multiplier;</span><br><span class="line">    scoreText.text = score.ToString(<span class="string">&quot;D12&quot;</span>);</span><br><span class="line">    ResetMultiplierCountdown();</span><br><span class="line">    OnMultiplierIncreased?.Invoke(multiplier);</span><br><span class="line">    UpdateMultiplierText();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// UpgradeManager.cs</span></span><br><span class="line">ScoreManager.OnMultiplierIncreased += handleMultiplierIncrease;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleMultiplierIncrease</span>(<span class="params"><span class="built_in">int</span> multiplier</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (multiplier &gt; maxMultiplierReached)</span><br><span class="line">    &#123;</span><br><span class="line">        maxMultiplierReached = multiplier;</span><br><span class="line">        <span class="keyword">if</span> (upgradeDict.ContainsKey(multiplier))</span><br><span class="line">        &#123;</span><br><span class="line">            TriggerUpgrade(upgradeDict[multiplier]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="连杀数关联升级模块"><a href="#连杀数关联升级模块" class="headerlink" title="连杀数关联升级模块"></a>连杀数关联升级模块</h2><p>本游戏有多种升级类型，如武器的伤害，弹夹容量，射速，攻击距离，新武器解锁等，可以定义一个枚举类型。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="built_in">enum</span> UpgradeType</span><br><span class="line">&#123;</span><br><span class="line">    Damage,         <span class="comment">// 伤害</span></span><br><span class="line">    Ammo,           <span class="comment">// 弹夹容量</span></span><br><span class="line">    FireRate,       <span class="comment">// 射速</span></span><br><span class="line">    ShootingRange,  <span class="comment">// 攻击距离</span></span><br><span class="line">    UnlockWeapon,   <span class="comment">// 新武器解锁</span></span><br><span class="line">    ShootingWide,   <span class="comment">// 射击宽度 （for霰弹枪）</span></span><br><span class="line">    ExplosionNums,  <span class="comment">// 爆炸次数 （for爆炸类武器）</span></span><br><span class="line">    ClusterExplode, <span class="comment">// 集束炸弹 （for爆炸类武器）</span></span><br><span class="line">    ExplosionRange, <span class="comment">// 爆炸范围 （for爆炸类武器）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们想要每一个升级条目都可以在Inspector中配置的，所以定义一个可序列化的结构体，表示一个升级条目。结构体内除了武器类型，升级类型外，还包含提升值，连杀数等属性。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">System.Serializable</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">UpgradeInfo</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> WeaponType weaponType;       <span class="comment">// 武器类型</span></span><br><span class="line">    <span class="keyword">public</span> UpgradeType type;            <span class="comment">// 升级类型</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> <span class="keyword">value</span>;                 <span class="comment">// 提升值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">bool</span> isMultiplicativeValue;  <span class="comment">// 是否倍增</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> UnlockMultiplier;        <span class="comment">// 多少连杀数解锁</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> DisplayName;          <span class="comment">// 展示名</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在UpgradeManager包含一个UpgradeInfo的数组和一个&lt;int, UgradeInfo&gt;的字典，在Inspector中为UpgardeInfo添加元素，游戏运行时将数组转化成键为连杀数，值为UpgradeInfo的字典，这样有了代理传过来的连杀数后就可以取出对应的UpgradeInfo。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Dictionary&lt;<span class="built_in">int</span>, UpgradeInfo&gt; upgradeDict = <span class="keyword">new</span> Dictionary&lt;<span class="built_in">int</span>, UpgradeInfo&gt;();</span><br></pre></td></tr></table></figure>

<h2 id="武器应用升级信息"><a href="#武器应用升级信息" class="headerlink" title="武器应用升级信息"></a>武器应用升级信息</h2><p>UpgradeManager获取UpgradeInfo后，将升级信息传给对应的武器。这里有一点要注意：不是每个武器都包含所有的升级类型，所以这里我们定义一些接口，如IUpgradeDamage，让可以升级伤害的武器实现该接口。下图展示了所有升级接口及实现它们的武器。<br><img src="/images/UpgradeInterface.png"><br>有了以上接口后，我们将所有升级信息都传给基类Weapon，Weapon判断它的子类是否实现了某接口，如果实现了，就调用子类的升级方法。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">UpgradeWith</span>(<span class="params">UpgradeInfo upgradeInfo</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">switch</span> (upgradeInfo.type)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> UpgradeType.Damage: <span class="comment">// 伤害</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">this</span> <span class="keyword">is</span> IUpgradeDamage upgradable)</span><br><span class="line">                    upgradable.UpgradeDamage(upgradeInfo.<span class="keyword">value</span>, upgradeInfo.isMultiplicativeValue);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    Debug.LogError(def.name + <span class="string">&quot;不可以升级&quot;</span> + upgradeInfo.type);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">case</span> UpgradeType.Ammo:  <span class="comment">// 弹夹容量</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">this</span> <span class="keyword">is</span> IUpgradeAmmo upgradable)</span><br><span class="line">                    upgradable.UpgradeAmmo(upgradeInfo.<span class="keyword">value</span>, upgradeInfo.isMultiplicativeValue);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    Debug.LogError(def.name + <span class="string">&quot;不可以升级&quot;</span> + upgradeInfo.type);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">case</span> UpgradeType.FireRate:  <span class="comment">// 攻速</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">this</span> <span class="keyword">is</span> IUpgradeFireRate upgradable)</span><br><span class="line">                    upgradable.UpgradeFireRate(upgradeInfo.<span class="keyword">value</span>, upgradeInfo.isMultiplicativeValue);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    Debug.LogError(def.name + <span class="string">&quot;不可以升级&quot;</span> + upgradeInfo.type);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">case</span> UpgradeType.ShootingRange: <span class="comment">// 攻击距离</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">this</span> <span class="keyword">is</span> IUpgradeShootingRange upgradable)</span><br><span class="line">                    upgradable.UpgradeShootingRange(upgradeInfo.<span class="keyword">value</span>, upgradeInfo.isMultiplicativeValue);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    Debug.LogError(def.name + <span class="string">&quot;不可以升级&quot;</span> + upgradeInfo.type);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">case</span> UpgradeType.ShootingWide: <span class="comment">// 射击宽度</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">this</span> <span class="keyword">is</span> IUpgradeShootingWide upgradable)</span><br><span class="line">                    upgradable.UpgradeShootingWide(upgradeInfo.<span class="keyword">value</span>, upgradeInfo.isMultiplicativeValue);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    Debug.LogError(<span class="string">&quot;射击范围不可升级&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">case</span> UpgradeType.ExplosionNums: <span class="comment">// 爆炸次数</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">this</span> <span class="keyword">is</span> IUpgradeExplosionNums upgradable)</span><br><span class="line">                    upgradable.UpgradeExplosionNums(upgradeInfo.<span class="keyword">value</span>, upgradeInfo.isMultiplicativeValue);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    Debug.LogError(<span class="string">&quot;爆炸次数不可升级&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">case</span> UpgradeType.ClusterExplode: <span class="comment">// 集束炸弹</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">this</span> <span class="keyword">is</span> IUpgradeClusterExplode upgradable)</span><br><span class="line">                    upgradable.UpgradeClusterExplode(upgradeInfo.<span class="keyword">value</span>, upgradeInfo.isMultiplicativeValue);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    Debug.LogError(<span class="string">&quot;集束爆炸不可升级&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">case</span> UpgradeType.ExplosionRange: <span class="comment">// 爆炸范围</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">this</span> <span class="keyword">is</span> IUpgradeExplosionRange upgradable)</span><br><span class="line">                    upgradable.UpgradeExplosionRange(upgradeInfo.<span class="keyword">value</span>, upgradeInfo.isMultiplicativeValue);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    Debug.LogError(<span class="string">&quot;爆炸范围不可提升&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="literal">default</span>:</span><br><span class="line">            &#123;</span><br><span class="line">                Debug.LogWarning(<span class="string">&quot;暂时没有处理该升级类型&quot;</span> + upgradeInfo.type);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="特殊的武器升级类型实现"><a href="#特殊的武器升级类型实现" class="headerlink" title="特殊的武器升级类型实现"></a>特殊的武器升级类型实现</h2><p>在武器升级类型中，伤害，子弹数，攻击速度，射击距离，射击范围，爆炸范围实现起来都比较简单，修改武器的属性即可。而爆炸次数和集束爆炸这两个针对爆炸类型的武器更为特殊，所以单独拿出来说明。</p>
<h3 id="爆炸次数BigBang"><a href="#爆炸次数BigBang" class="headerlink" title="爆炸次数BigBang"></a>爆炸次数BigBang</h3><p>原作中有一条武器增益为BigBang，它将爆炸物的爆炸次数由一次提升到了三次。如下图。<br><img src="/images/BigBang.gif"><br>要实现这样的效果，我们为爆炸物的爆炸点由单个Transform改为一个Transform数组，在爆炸判断当前武器是否已经解锁了BagBang，如果已经解锁则在每个Transform依次调用Explode，反之则在Transform[0]处爆炸。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Explode</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (explosionNums == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        explode(explosionTrans[<span class="number">0</span>]);</span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        StartCoroutine(ExplodeInOrder(explosionInterval));</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> IEnumerator <span class="title">ExplodeInOrder</span>(<span class="params"><span class="built_in">float</span> interval</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; explosionTrans.Length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        explode(explosionTrans[i]);</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">yield</span> <span class="keyword">return</span> <span class="keyword">new</span> <span class="title">WaitForSeconds</span>(<span class="params">interval</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="集束爆炸ClusterExplode"><a href="#集束爆炸ClusterExplode" class="headerlink" title="集束爆炸ClusterExplode"></a>集束爆炸ClusterExplode</h3><p>ClusterExplode是另一个特殊的爆炸物增益效果，它指的是武器爆炸后，会分裂出四个小炸弹向四周弹出，然后再次爆炸的效果。如下图。<br><img src="/images/ClusterExplode.gif"><br>尽管小炸弹和Grenade看起来极其相似，但是为了不增加耦合度，新建一个Prefab，绑定脚本SubGrenade。在爆炸物爆炸后，初始化四个子炸弹，给每个子炸弹的刚体组件一个从爆炸中心到四个子炸弹位置方向的初速度，子炸弹在接触到地面后爆炸。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Grenade.cs</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">clusterExplode</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        GameObject go = Instantiate(subGrenade) <span class="keyword">as</span> GameObject;</span><br><span class="line">        go.transform.position = subGrenadeTrans[i].position;</span><br><span class="line"></span><br><span class="line">        Rigidbody rb = go.GetComponent&lt;Rigidbody&gt;();</span><br><span class="line">        Vector3 direction = Vector3.Normalize(go.transform.position - transform.position);</span><br><span class="line">        rb.AddForce(direction * splitForce, ForceMode.Impulse);</span><br><span class="line"></span><br><span class="line">        SubBomb sb = go.GetComponent&lt;SubBomb&gt;();</span><br><span class="line">        sb.Damage = damage / <span class="number">4</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// SubBomb.cs</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnTriggerEnter</span>(<span class="params">Collider other</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (other.CompareTag(<span class="string">&quot;Floor&quot;</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        Explode();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="敌人寻路续"><a href="#敌人寻路续" class="headerlink" title="敌人寻路续"></a>敌人寻路续</h1><h2 id="Navigation-AI"><a href="#Navigation-AI" class="headerlink" title="Navigation AI"></a>Navigation AI</h2><p>我们在敌人移动一节已经介绍了Unity中Navigation AI的基本使用，我们再次回忆一下一个基本寻路系统的实现步骤：</p>
<ul>
<li>给需要寻路的对象绑定一个NavMeshAgent组件</li>
<li>将场景中的建筑（地面和墙）设置为static</li>
<li>为油桶、假墙这类障碍物添加NavMeshObstacle组件</li>
<li>在Navigation窗口中点击烘焙，生成NavMesh</li>
<li>为需要寻路的对象设置Destination</li>
</ul>
<p>武器系统里包含两种武器：油桶和假墙。它们会在游戏运行时被玩家放置，所以我们需要检查当这两种武器被放置时，NavMesh有没有动态的更新，以下是我对油桶测试得到的结果：<br><img src="/images/RuntimeNav.gif"></p>
<p>通过上图可以发现：</p>
<ol>
<li>在运行时放置油桶改变了Navmesh，且油桶消失后Navmesh复原。注意油桶的obstacle组件需要勾选Curve。</li>
<li>敌人的路线也因为障碍物而发生了改变。<br>所以看起来unity自带的navigation是支持运行时NavMesh的，不需要借助其它工具。<br>但是我们还有另一个需求，对于普通僵尸而言，我们希望油桶和假墙作为障碍物，普通僵尸遇到时会主动避让，但是对于红色僵尸，我们不希望油桶和假墙影响它的行进路线，当遇到这两种物体时，僵尸会主动攻击直到障碍物被破坏。<br>为了实现这个功能，至少需要实现两点；</li>
<li>对普通僵尸和红色僵尸应用不同的agent type;</li>
<li>障碍物需要能够设置它影响的agent type。<br>对于第一个问题，我们在navigation窗口新增两个Agent type，一个为Zombie, 另一个为Boss，修改NavMeshAgent里的类型属性为对应值。但是运行后，发现控制台疯狂弹以下错误。<br><img src="/images/AgentTypeError.gif"><br>查了一下发现也有童鞋遇到一样的问题，而且没有好的解法。</li>
</ol>
<p>对于第二个问题，NavMeshObstacle组件不能够指定影响的Agent type。</p>
<h2 id="NavMeshComponents"><a href="#NavMeshComponents" class="headerlink" title="NavMeshComponents"></a>NavMeshComponents</h2><p>以上两个问题都不太好解决，又查了很多资料，原来Unity官方还提供了一个<a target="_blank" rel="noopener" href="https://github.com/Unity-Technologies/NavMeshComponents">更高级的NevMesh组件</a>，这个组件不在unity的下载包中，需要手动导入。<br>官方给出了导入方式，打开Package Manager窗口，点击+号，选择Add package by name，输入com.unity.ai.navigation，然后import。<br>在<a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=fBu4_psgTXs">油管</a>上找了一个视频，学习了一下这个套件的使用方法。<br>在介绍使用之前需要了解一些基本概念，这个components的核心是四个组件：</p>
<ul>
<li>NavMeshSurface – for building and enabling a NavMesh surface for one agent type.</li>
<li>NavMeshModifier – affects the NavMesh generation of NavMesh area types, based on the transform hierarchy.</li>
<li>NavMeshModifierVolume – affects the NavMesh generation of NavMesh area types, based on volume.</li>
<li>NavMeshLink – connects same or different NavMesh surfaces for one agent type.</li>
</ul>
<p>简单概括一下：<br>NavMeshSurface是导航的平面，给需要渲染NavMesh的所有对象的父节点添加。<br>NavMeshModifier有点类似于NavMeshObstacle，通过它我们可以确定一个物体是否应该作为一个障碍物。它相对于NavMeshObstacle的优势是它可以指定影响的agents。<br>NavMeshModifierVolume可以框出一个空间，使它成为障碍物，空对象也可以使用。<br>NavMeshLink用于连接两个NavMesh平面，在本项目中不会使用。<br>用NavMeshComponents实现寻路的步骤是：</p>
<ul>
<li>给需要寻路的对象绑定NavMeshAgent组件，并指定Agent Type</li>
<li>给障碍物绑定NavMeshModifier，对于油桶和假墙，我们希望它不影响红色僵尸的导航，所以勾选Ignore From Build，并将Affected Agents设为Boss。</li>
<li>对要生成NavMesh的所有对象的父对象添加NavMeshSurface组件，zombie和boss各需要一个NavMeshSurface，设置好各自的AgentType，其它设置如图5.3，最后点击Bake。<br><img src="/images/NavMeshSurface.png"></li>
<li>最后同样的，代码中设置Destination。<br>为了让红色僵尸在遇到油桶和假墙时停止并攻击，我们在代码里还要添加一个判断逻辑。<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((isInAttackRange &amp;&amp; isFaceToTarget()) || isBlockByFakeWall())</span><br><span class="line">&#123;</span><br><span class="line">    agent.isStopped = <span class="literal">true</span>;</span><br><span class="line">    animator.SetBool(<span class="string">&quot;attack&quot;</span>, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
以上实现逻辑没有问题，但是在使用的过程中还是遇到了一些坑：</li>
</ul>
<ol>
<li>运行代码后，发现僵尸的移动有异常，有的僵尸停在初始位置，有的僵尸走了一会然后就停住不动了。这个问题困扰了我很久，谷歌也搜不到相关的结果。偶然的机会我disable了NavMeshSurface组件，发现僵尸的行走正常了，这时我才想到会不会<strong>Unity自带的navigation组件bake的Navmesh不能与NavMeshSurface组件bake的NavMesh混用</strong>？于是我clear了Navigation Bake的NavMesh，僵尸移动正常了。</li>
<li>场景中的建筑的层级结构如下图，一开始我将NavMeshSurface组件加在了Floor上，并且将Surface组件的Collect Objects设为Children，如图5.3，且Barrels对象和Building同级。这时点击Bake会发现场景中的油桶没有作为障碍物渲染NavMesh，后来查了才知道NavMeshSurface必须要加在要渲染NavMesh的对象的<strong>父对象</strong>上。所以我将NavMeshSurface绑定在Building上，Barrels从Building的同级改为子对象，并且游戏中生成的所有Barrel和FakeWall都作为Building的子对象，之后NavMesh渲染正常。<br><img src="/images/BuildingHierchey.png"></li>
</ol>
<h1 id="游戏界面UI"><a href="#游戏界面UI" class="headerlink" title="游戏界面UI"></a>游戏界面UI</h1><p>如图游戏界面UI由几个部分组成：屏幕上方的得分数，连杀数；敌人死亡后的飘屏得分；下方的各类文字提示。下面依次介绍实现：<br><img src="/images/HUD.png"></p>
<h2 id="得分及连杀数"><a href="#得分及连杀数" class="headerlink" title="得分及连杀数"></a>得分及连杀数</h2><p>自杀敌人的得分取决于僵尸类型和连杀数。<br>普通僵尸的得分为10x连杀数，红色僵尸的得分为1000x连杀数。<br>屏幕上方显示总得分，为了让其显示为12位数，使用ToString(“D12”)格式化。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">IncreseScore</span>(<span class="params"><span class="built_in">int</span> points</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (multiplier == maxMultiplier)</span><br><span class="line">    &#123;</span><br><span class="line">        ResetMultiplierCountdown();</span><br><span class="line">        score += points * multiplier;</span><br><span class="line">        scoreText.text = score.ToString();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    multiplier++;</span><br><span class="line">    score += points * multiplier;</span><br><span class="line">    scoreText.text = score.ToString(<span class="string">&quot;D12&quot;</span>);</span><br><span class="line">    ResetMultiplierCountdown();</span><br><span class="line">    OnMultiplierIncreased?.Invoke(multiplier);</span><br><span class="line">    UpdateMultiplierText();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于飘屏得分我们可以创建好Text的预设，每当敌人死亡时，初始化一个Text预设，将其初始位置设置为敌人的位置。注意这里我们需要将世界坐标系转化为Canvas坐标系，算法参考<a target="_blank" rel="noopener" href="https://answers.unity.com/questions/799616/unity-46-beta-19-how-to-convert-from-world-space-t.html">UnityAnswer</a>。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Vector2 <span class="title">WorldtoCanvasPosition</span>(<span class="params">Vector3 position</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Vector2 temp = cam.WorldToViewportPoint(position);</span><br><span class="line"></span><br><span class="line">    temp.x *= canvasRect.sizeDelta.x;</span><br><span class="line">    temp.y *= canvasRect.sizeDelta.y;</span><br><span class="line"></span><br><span class="line">    temp.x -= canvasRect.sizeDelta.x * canvasRect.pivot.x;</span><br><span class="line">    temp.y -= canvasRect.sizeDelta.y * canvasRect.pivot.y;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>之后需要将Text逐渐位移至屏幕上方的总得分区域，距离足够近时销毁。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (Vector3.Distance(currentlyMovingTexts[i].transform.position, score.transform.position) &lt;= minDistanceToScoreText)</span><br><span class="line">&#123;</span><br><span class="line">    TMP_Text text = currentlyMovingTexts[i];</span><br><span class="line">    currentlyMovingTexts.RemoveAt(i);</span><br><span class="line">    Destroy(text);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    currentlyMovingTexts[i].transform.position = Vector3.MoveTowards(currentlyMovingTexts[i].transform.position, score.transform.position, Time.deltaTime * textMoveSpeed);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>连杀数需要格式化为“x连杀数”的格式，用string.Format实现。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">multiplierText.text = <span class="built_in">string</span>.Format(<span class="string">&quot;x&#123;0&#125;&quot;</span>, multiplier);</span><br></pre></td></tr></table></figure>

<h2 id="文字提示"><a href="#文字提示" class="headerlink" title="文字提示"></a>文字提示</h2><p>游戏中玩家切换武器，解锁武器，解锁升级，拾取物品，子弹用尽，关卡升级等都会在屏幕下方输出一条文字信息。<br>文字信息依次排列在屏幕正下方，有最大条数限制，达到最大条数后，最上面一条会消失，同时每条信息在一定时间后也会消失。<br>我们可以为所有的文字信息设置一个父对象，用<a target="_blank" rel="noopener" href="https://docs.unity3d.com/Packages/com.unity.ugui@1.0/manual/script-VerticalLayoutGroup.html">Vertical Layout Group</a>垂直排列文本信息。<br>每条文字信息是一个Text对象，需要为text设置颜色以及在父对象中的index，所以定义一个结构体TextLogEntry。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TextLogEntry</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> TextMeshProUGUI TextMesh &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Index &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TextLogEntry</span>(<span class="params">TextMeshProUGUI textMesh, <span class="built_in">int</span> index, Color color</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.TextMesh = textMesh;</span><br><span class="line">        <span class="keyword">this</span>.Index = index;</span><br><span class="line">        <span class="keyword">this</span>.TextMesh.color = color;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SetText</span>(<span class="params"><span class="built_in">string</span> text</span>)</span> =&gt; TextMesh.text = text;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">MoveToIndex</span>(<span class="params"><span class="built_in">int</span> index</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Index = index;</span><br><span class="line">        TextMesh.transform.SetSiblingIndex(index);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Destroy</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        GameObject.Destroy(TextMesh.gameObject);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为父对象绑定一个脚本InfoTextManager，它持有一个TextLogEntry的数组textLogs。<br>我们通过代理往拾取武器，武器升级，武器切换等事件传入函数指针，当事件发生时，回调InfoTextManager对应的方法，往textlogs添加一条文本信息。<br>这里以武器解锁文本为例：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// InfoTextManager.cs</span></span><br><span class="line"><span class="comment">// 回调</span></span><br><span class="line">player.onWeaponUnlocked -= AddUnlockWeaponTextEntry;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 武器解锁文本</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">AddUnlockWeaponTextEntry</span>(<span class="params">Weapon weapon</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    TextMeshProUGUI textMesh = Instantiate(textPrefab, transform);</span><br><span class="line">    TextLogEntry logEntry = <span class="keyword">new</span> TextLogEntry(textMesh, textLog.Count, Color.green);</span><br><span class="line">    logEntry.SetText(<span class="built_in">string</span>.Format(unlockTextString, weapon.GetWeaponDef().name));</span><br><span class="line">    AddAndShowTextLogEntry(logEntry);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 往list里添加一条文字信息</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">AddAndShowTextLogEntry</span>(<span class="params">TextLogEntry logEntry</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (textLog.Count == maxAmountEntries)</span><br><span class="line">        FadeOutEntryAfterDelay(<span class="number">0f</span>, fadeOutSpeed, textLog[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    textLog.Add(logEntry);</span><br><span class="line">    logEntry.MoveToIndex(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    StartCoroutine(FadeOutEntryAfterDelay(showTime, fadeOutSpeed, logEntry));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在AddAndShowTextLogEntry方法的最后，开启一个协程，在协程里让该条文本消失。<br>消失时改变文字透明度，透明度变成0时从数组里移除Text对象，并销毁。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> IEnumerator <span class="title">FadeOutEntryAfterDelay</span>(<span class="params"><span class="built_in">float</span> delay, <span class="built_in">float</span> speed, TextLogEntry entry</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">yield</span> <span class="keyword">return</span> <span class="keyword">new</span> <span class="title">WaitForSeconds</span>(<span class="params">delay</span>)</span>;</span><br><span class="line">    <span class="keyword">while</span>(entry.TextMesh.color.a &gt; <span class="number">0.0f</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Color modified = entry.TextMesh.color;</span><br><span class="line">        modified.a -= (Time.deltaTime * speed);</span><br><span class="line">        entry.TextMesh.color = modified;</span><br><span class="line">        <span class="keyword">yield</span> <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    entry.Destroy();</span><br><span class="line">    textLog.Remove(entry);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="音效系统"><a href="#音效系统" class="headerlink" title="音效系统"></a>音效系统</h1><p>本项目还原了以下音效。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">十种武器对应的射击声</span><br><span class="line">爆炸声</span><br><span class="line">物品拾取声</span><br><span class="line">玩家死亡叫声</span><br><span class="line">敌人死亡叫声</span><br><span class="line">下一关音效</span><br></pre></td></tr></table></figure>
<p>音源来自原游戏通过<a target="_blank" rel="noopener" href="https://github.com/jindrapetrik/jpexs-decompiler">ffdec</a>反编译得到的资源文件。</p>
<p>定义一个AudioManager，绑定到一个空对象中。AudioManager负责播放AudioSource。<br>AudioManager作为一个需要被各个脚本频繁调用的管理器，适合使用单例的设计模式。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">AudioManager</span> : <span class="title">Singleton</span>&lt;<span class="title">AudioManager</span>&gt;</span><br></pre></td></tr></table></figure>
<p>我们定义一个结构体Sound，包含AudioSource，AudioClip，用来查找AudioClip的name，以及Volume表示音量大小。AudioManager持有Sound数组。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Sound</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> AudioSource source;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> name;</span><br><span class="line">    <span class="keyword">public</span> AudioClip clip;</span><br><span class="line">    [<span class="meta">Range(0f, 1f)</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> volume;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSource</span>(<span class="params">AudioSource source</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.source = source;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>播放音效时，我们传入一个字符串，在Sound数组里查找对应的元素，并播放。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Play</span>(<span class="params"><span class="built_in">string</span> name</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Sound s = Array.Find(sounds, sound =&gt; sound.name == name);</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Debug.LogWarning(<span class="string">&quot;Sound [&quot;</span> + name + <span class="string">&quot;] not found.&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    s.source.Play();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="关卡系统"><a href="#关卡系统" class="headerlink" title="关卡系统"></a>关卡系统</h1><p>由于不好观察出原作关卡系统的设计机制，所以在本项目里根据自己的理解设计了一套简易的关卡系统。<br>首先定义一个可序列化的结构体LevelInfo表示每关的敌人生成信息。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">LevelInfo</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span>   levelIndex;      <span class="comment">// 第几关</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span>   enemyAmount;     <span class="comment">// 敌人数量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> ememySpawnRate;  <span class="comment">// 敌人生成速率</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> enemyMoveSpeed;  <span class="comment">// 敌人移动速度</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span>   bossAmount;      <span class="comment">// boss数量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> bossSpawnRate;   <span class="comment">// boss生成速率</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> bossMoveSpeed;   <span class="comment">// boss移动速度</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们需要在当前关卡结束的时候进入到下一关并生成敌人。可以分成两个问题：如何判断当前关卡已经结束和如何生成新一关的敌人。<br><strong>判断当前关卡结束</strong><br>在敌人生成器EnemySpawner里生成一个变量hasFinishedSpawning，标识该生成点已经生成完全部僵尸。我们可以遍历所有的EnemySpawner，判断是否每一个生成点都已经生成完所有僵尸。<br>同时，玩家必须杀完场上所有僵尸关卡才算结束，EnemyManger中记录着当前场上的僵尸数量。结合以上两个条件，就可以知道该关是否结束。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> IEnumerator <span class="title">UpdateLevelFinish</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">yield</span> <span class="keyword">return</span> <span class="keyword">new</span> <span class="title">WaitForSeconds</span>(<span class="params"><span class="number">0.5f</span></span>)</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">foreach</span> (EnemySpawner s <span class="keyword">in</span> enemySpawners)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (!s.hasFinishedSpawning)</span><br><span class="line">            &#123;</span><br><span class="line">                flag = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        levelFinished = flag &amp;&amp; enemyManager.CurrentEnemiesCount == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>生成下一关的敌人</strong><br>普通僵尸：对于每个生成点，我们生成相等数量的僵尸，所以遍历一遍EnemySpawner，为每个生产点创建EnemyWave，指定僵尸类型，数量，生成间隔。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; enemySpawners.Count; i++)</span><br><span class="line">&#123;</span><br><span class="line">    enemySpawners[i].enmeyWaves.Clear();</span><br><span class="line">    EnemyWave wave = <span class="keyword">new</span> EnemyWave();</span><br><span class="line">    wave.EnemyType = EnemyType.Zombie;</span><br><span class="line">    wave.Amount = level.enemyAmount / enemySpawners.Count;</span><br><span class="line">    wave.TimeBetweenSpawn = level.ememySpawnRate + Random.Range(<span class="number">-0.5f</span>, <span class="number">0.5f</span>);</span><br><span class="line">    enemySpawners[i].enmeyWaves.Add(wave);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>红色僵尸：红色僵尸的数量较少，一般少于生成点的个数，所以随机取一个生成点，创建一个Boss类型的EnemyWave。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Boss</span></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; level.bossAmount; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> index = Random.Range(<span class="number">0</span>, enemySpawners.Count - <span class="number">1</span>);</span><br><span class="line">    EnemyWave wave = <span class="keyword">new</span> EnemyWave();</span><br><span class="line">    wave.EnemyType = EnemyType.Boss;</span><br><span class="line">    wave.Amount = <span class="number">1</span>;</span><br><span class="line">    wave.TimeBetweenSpawn = level.bossSpawnRate + Random.Range(<span class="number">-0.5f</span>, <span class="number">0.5f</span>);</span><br><span class="line">    enemySpawners[index].enmeyWaves.Add(wave);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后，重置EnmeySpawner里的状态，使它能够继续生成敌人。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LevelManager.cs</span></span><br><span class="line"><span class="keyword">foreach</span>(EnemySpawner enemy <span class="keyword">in</span> enemySpawners)</span><br><span class="line">&#123;</span><br><span class="line">    enemy.Refresh();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// EnmeySpawner.cs</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Refresh</span>() <span class="comment">// 重置倒计时及状态</span></span></span><br><span class="line">&#123;</span><br><span class="line">    countdown = initialSpawnDelay; </span><br><span class="line">    hasFinishedSpawning = <span class="literal">false</span>;</span><br><span class="line">    currentWaveIndex = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="游戏管理"><a href="#游戏管理" class="headerlink" title="游戏管理"></a>游戏管理</h1><p>目前仅实现了游戏的暂停。</p>
<h2 id="暂停"><a href="#暂停" class="headerlink" title="暂停"></a>暂停</h2><p>修改Time.timeScale为0秒</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (Input.GetKeyDown(KeyCode.P)) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!isPaused)</span><br><span class="line">        &#123;</span><br><span class="line">            Time.timeScale = <span class="number">0.0f</span>;</span><br><span class="line">            isPaused = <span class="literal">true</span>;</span><br><span class="line">            gameOverText.gameObject.SetActive(<span class="literal">true</span>);</span><br><span class="line">            gameOverText.text = <span class="string">&quot;Paused!&quot;</span>;</span><br><span class="line">            OnPause?.Invoke();</span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            Time.timeScale = <span class="number">1.0f</span>;</span><br><span class="line">            isPaused = <span class="literal">false</span>;</span><br><span class="line">            gameOverText.gameObject.SetActive(<span class="literal">false</span>);</span><br><span class="line">            gameOverText.text = <span class="string">&quot;&quot;</span>;</span><br><span class="line">            onResume?.Invoke();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">梓见</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2022/09/27/zombieCrisis/">http://example.com/2022/09/27/zombieCrisis/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">梓见</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/11/07/ssao/"><img class="prev-cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">OpenGL实现屏幕空间的环境光遮蔽（SSAO）</div></div></a></div><div class="next-post pull-right"><a href="/2022/05/03/hello-world/"><img class="next-cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Hello World</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://cdn.jsdelivr.net/gh/uestctangzijian/picbed@main/kabi.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">梓见</div><div class="author-info__description">记录生活学习的点点滴滴</div></div><div class="card-info-data is-center"><div class="card-info-data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">3</div></a></div><div class="card-info-data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a></div><div class="card-info-data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/uestctangzijian" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:420872708@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9C%B0%E5%9B%BE%E8%AE%BE%E8%AE%A1"><span class="toc-number">1.</span> <span class="toc-text">地图设计</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%8E%A9%E5%AE%B6%E8%AE%BE%E8%AE%A1"><span class="toc-number">2.</span> <span class="toc-text">玩家设计</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%8E%A9%E5%AE%B6%E8%A1%8C%E8%B5%B0"><span class="toc-number">2.1.</span> <span class="toc-text">玩家行走</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%8E%A9%E5%AE%B6%E6%94%BB%E5%87%BB"><span class="toc-number">2.2.</span> <span class="toc-text">玩家攻击</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%9F%E5%91%BD%E7%AE%A1%E7%90%86"><span class="toc-number">2.3.</span> <span class="toc-text">生命管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%A4%E5%AE%B3%E5%8F%8A%E6%B2%BB%E7%96%97"><span class="toc-number">2.3.1.</span> <span class="toc-text">伤害及治疗</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A1%80%E6%B8%8D%E6%95%88%E6%9E%9C"><span class="toc-number">2.3.2.</span> <span class="toc-text">血渍效果</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BB%E9%80%80%E6%95%88%E6%9E%9C"><span class="toc-number">2.3.3.</span> <span class="toc-text">击退效果</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%8C%E4%BA%BA%E8%AE%BE%E8%AE%A1"><span class="toc-number">3.</span> <span class="toc-text">敌人设计</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%8C%E4%BA%BA%E7%A7%BB%E5%8A%A8"><span class="toc-number">3.1.</span> <span class="toc-text">敌人移动</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%8C%E4%BA%BA%E6%94%BB%E5%87%BB"><span class="toc-number">3.2.</span> <span class="toc-text">敌人攻击</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%99%AE%E9%80%9A%E5%83%B5%E5%B0%B8"><span class="toc-number">3.2.1.</span> <span class="toc-text">普通僵尸</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%A2%E8%89%B2%E5%83%B5%E5%B0%B8%EF%BC%88Boss%EF%BC%89"><span class="toc-number">3.2.2.</span> <span class="toc-text">红色僵尸（Boss）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%9F%E5%91%BD%E7%AE%A1%E7%90%86-1"><span class="toc-number">3.3.</span> <span class="toc-text">生命管理</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8A%A8%E7%94%BB%E7%B3%BB%E7%BB%9F"><span class="toc-number">4.</span> <span class="toc-text">动画系统</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">4.1.</span> <span class="toc-text">基本概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Animator%E7%BB%84%E4%BB%B6"><span class="toc-number">4.1.1.</span> <span class="toc-text">Animator组件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Animator-Controller%E5%8A%A8%E7%94%BB%E6%8E%A7%E5%88%B6%E5%99%A8"><span class="toc-number">4.1.2.</span> <span class="toc-text">Animator Controller动画控制器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Animation-x2F-Animation-Clip%E5%8A%A8%E7%94%BB%E7%89%87%E6%AE%B5"><span class="toc-number">4.1.3.</span> <span class="toc-text">Animation&#x2F;Animation Clip动画片段</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%A8%E7%94%BB%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2"><span class="toc-number">4.2.</span> <span class="toc-text">动画状态转换</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%A8%E7%94%BB%E5%88%87%E7%89%87%E5%88%B6%E4%BD%9C"><span class="toc-number">4.3.</span> <span class="toc-text">动画切片制作</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%8C%E4%BA%BA%E7%94%9F%E6%88%90%E5%99%A8"><span class="toc-number">5.</span> <span class="toc-text">敌人生成器</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%AD%A6%E5%99%A8%E7%B3%BB%E7%BB%9F"><span class="toc-number">6.</span> <span class="toc-text">武器系统</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E6%80%9D%E8%B7%AF"><span class="toc-number">6.1.</span> <span class="toc-text">设计思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Weapon%E5%9F%BA%E7%B1%BB"><span class="toc-number">6.2.</span> <span class="toc-text">Weapon基类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Pistol-%E6%89%8B%E6%9E%AA"><span class="toc-number">6.3.</span> <span class="toc-text">Pistol 手枪</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#UZI-%E5%86%B2%E9%94%8B%E6%9E%AA"><span class="toc-number">6.4.</span> <span class="toc-text">UZI 冲锋枪</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Shotgun-%E9%9C%B0%E5%BC%B9%E6%9E%AA"><span class="toc-number">6.5.</span> <span class="toc-text">Shotgun 霰弹枪</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Barrel-%E6%B1%BD%E6%B2%B9%E6%A1%B6"><span class="toc-number">6.6.</span> <span class="toc-text">Barrel 汽油桶</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Genrade-%E6%89%8B%E6%A6%B4%E5%BC%B9"><span class="toc-number">6.7.</span> <span class="toc-text">Genrade 手榴弹</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#FakeWall-%E5%81%87%E5%A2%99"><span class="toc-number">6.8.</span> <span class="toc-text">FakeWall 假墙</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Claymore-%E5%9C%B0%E9%9B%B7"><span class="toc-number">6.9.</span> <span class="toc-text">Claymore 地雷</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ChargePack-%E9%81%A5%E6%8E%A7%E7%82%B8%E5%BC%B9"><span class="toc-number">6.10.</span> <span class="toc-text">ChargePack 遥控炸弹</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Rocket-%E7%81%AB%E7%AE%AD%E7%82%AE"><span class="toc-number">6.11.</span> <span class="toc-text">Rocket 火箭炮</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Railgun-%E9%95%AD%E5%B0%84%E6%9E%AA"><span class="toc-number">6.12.</span> <span class="toc-text">Railgun 镭射枪</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AD%A6%E5%99%A8%E5%88%87%E6%8D%A2"><span class="toc-number">6.13.</span> <span class="toc-text">武器切换</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8D%87%E7%BA%A7%E7%B3%BB%E7%BB%9F"><span class="toc-number">7.</span> <span class="toc-text">升级系统</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9E%E6%9D%80%E6%95%B0"><span class="toc-number">7.1.</span> <span class="toc-text">连杀数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9E%E6%9D%80%E6%95%B0%E5%85%B3%E8%81%94%E5%8D%87%E7%BA%A7%E6%A8%A1%E5%9D%97"><span class="toc-number">7.2.</span> <span class="toc-text">连杀数关联升级模块</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AD%A6%E5%99%A8%E5%BA%94%E7%94%A8%E5%8D%87%E7%BA%A7%E4%BF%A1%E6%81%AF"><span class="toc-number">7.3.</span> <span class="toc-text">武器应用升级信息</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%89%B9%E6%AE%8A%E7%9A%84%E6%AD%A6%E5%99%A8%E5%8D%87%E7%BA%A7%E7%B1%BB%E5%9E%8B%E5%AE%9E%E7%8E%B0"><span class="toc-number">7.4.</span> <span class="toc-text">特殊的武器升级类型实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%88%86%E7%82%B8%E6%AC%A1%E6%95%B0BigBang"><span class="toc-number">7.4.1.</span> <span class="toc-text">爆炸次数BigBang</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9B%86%E6%9D%9F%E7%88%86%E7%82%B8ClusterExplode"><span class="toc-number">7.4.2.</span> <span class="toc-text">集束爆炸ClusterExplode</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%8C%E4%BA%BA%E5%AF%BB%E8%B7%AF%E7%BB%AD"><span class="toc-number">8.</span> <span class="toc-text">敌人寻路续</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Navigation-AI"><span class="toc-number">8.1.</span> <span class="toc-text">Navigation AI</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#NavMeshComponents"><span class="toc-number">8.2.</span> <span class="toc-text">NavMeshComponents</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%B8%B8%E6%88%8F%E7%95%8C%E9%9D%A2UI"><span class="toc-number">9.</span> <span class="toc-text">游戏界面UI</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BE%97%E5%88%86%E5%8F%8A%E8%BF%9E%E6%9D%80%E6%95%B0"><span class="toc-number">9.1.</span> <span class="toc-text">得分及连杀数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%87%E5%AD%97%E6%8F%90%E7%A4%BA"><span class="toc-number">9.2.</span> <span class="toc-text">文字提示</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%9F%B3%E6%95%88%E7%B3%BB%E7%BB%9F"><span class="toc-number">10.</span> <span class="toc-text">音效系统</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%B3%E5%8D%A1%E7%B3%BB%E7%BB%9F"><span class="toc-number">11.</span> <span class="toc-text">关卡系统</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%B8%B8%E6%88%8F%E7%AE%A1%E7%90%86"><span class="toc-number">12.</span> <span class="toc-text">游戏管理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9A%82%E5%81%9C"><span class="toc-number">12.1.</span> <span class="toc-text">暂停</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2022/11/07/ssao/" title="OpenGL实现屏幕空间的环境光遮蔽（SSAO）"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="OpenGL实现屏幕空间的环境光遮蔽（SSAO）"/></a><div class="content"><a class="title" href="/2022/11/07/ssao/" title="OpenGL实现屏幕空间的环境光遮蔽（SSAO）">OpenGL实现屏幕空间的环境光遮蔽（SSAO）</a><time datetime="2022-11-07T15:49:54.000Z" title="发表于 2022-11-07 23:49:54">2022-11-07</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/09/27/zombieCrisis/" title="《僵尸危机：Unity重置版》开发全纪录"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="《僵尸危机：Unity重置版》开发全纪录"/></a><div class="content"><a class="title" href="/2022/09/27/zombieCrisis/" title="《僵尸危机：Unity重置版》开发全纪录">《僵尸危机：Unity重置版》开发全纪录</a><time datetime="2022-09-26T19:06:21.000Z" title="发表于 2022-09-27 03:06:21">2022-09-27</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/05/03/hello-world/" title="Hello World"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Hello World"/></a><div class="content"><a class="title" href="/2022/05/03/hello-world/" title="Hello World">Hello World</a><time datetime="2022-05-03T07:42:47.243Z" title="发表于 2022-05-03 15:42:47">2022-05-03</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By 梓见</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>